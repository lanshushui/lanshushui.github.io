<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASM知识点</title>
    <url>/post/3098f3f8.html</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/16ed4d233fd1">【Android】函数插桩（Gradle + ASM）</a></p>
<p>通过上面的大神教程，学习在自定义函数前后进行插桩，满足打点日志的需求。</p>
<p>但如果想要知道APP中什么时候调用系统的方法，例如想要知道APP【哪些地方】【什么时候】调用了 context.getSystemService() 方法，以及当时的堆栈，</p>
<p>Hook替换掉context.getSystemService()这一行代码为是最简单的操作</p>
<p><em>利用ASM的  <strong>AdviceAdapter</strong> 类和  <strong>INVOKESTATIC</strong>  操作码很容易就实现函数的Hook替换功能</em></p>
<span id="more"></span>



<h2 id="1-自定义AdviceAdapter"><a href="#1-自定义AdviceAdapter" class="headerlink" title="1.自定义AdviceAdapter"></a>1.自定义AdviceAdapter</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodHookAdapter</span>(</span><br><span class="line">    mv: MethodVisitor,</span><br><span class="line">    desc: String,</span><br><span class="line">    name: String,</span><br><span class="line">    access: <span class="built_in">Int</span></span><br><span class="line">) : AdviceAdapter(Opcodes.ASM5, mv, access, name, desc) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitMethodInsn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        opcode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        owner: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        descriptor: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        isInterface: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isHook(opcode,owner,name,descriptor,isInterface)) &#123;</span><br><span class="line">            <span class="comment">//满足hook条件，则替换成自定义的static函数</span></span><br><span class="line">            <span class="keyword">super</span>.visitMethodInsn(</span><br><span class="line">                INVOKESTATIC,</span><br><span class="line">                newOwner,</span><br><span class="line">                newMethodName,</span><br><span class="line">                newMethodDesc,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, descriptor, isInterface)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但对自定义Hook函数的newMethodDesc有一定的要求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果hook的函数是实例对象的函数，即操作码是INVOKESPECIAL。自定义Hook函数的参数列表必须是 [要Hook的对象类，Hook函数原本的参数列表]</span><br><span class="line">如果hook的函数是静态函数，即操作码是INVOKESTATIC。自定义Hook函数的参数列表则保持一致    [Hook函数原本的参数列表]</span><br></pre></td></tr></table></figure>



<p>用例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookA</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//hook A.a()方法，参数列表最前面必须加个A的参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hookA</span><span class="params">(A a, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//hook A.b()方法，参数列表保持一致</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hookB</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Hook参数列表为什么必须这样子设计？"><a href="#2-Hook参数列表为什么必须这样子设计？" class="headerlink" title="2.Hook参数列表为什么必须这样子设计？"></a>2.Hook参数列表为什么必须这样子设计？</h2><h6 id="分析字节码-1"><a href="#分析字节码-1" class="headerlink" title="分析字节码-1"></a><em>分析字节码-1</em></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">void a()&#123;</span><br><span class="line">    Context context= new Activity();</span><br><span class="line">    <span class="comment">//调用实例方法</span></span><br><span class="line">    Object systemService = context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为上面a函数的字节码</span></span><br><span class="line"></span><br><span class="line">.method a()V</span><br><span class="line">.registers <span class="number">3</span></span><br><span class="line"></span><br><span class="line">.line <span class="number">9</span></span><br><span class="line"><span class="comment">//调用Activity()方法，将返回值放进v0寄存器中</span></span><br><span class="line">new-instance v0, Landroid/app/Activity;</span><br><span class="line"><span class="comment">//调用v0寄存器中的实例对象的init方法</span></span><br><span class="line">invoke-direct &#123;v0&#125;, Landroid/app/Activity;-&gt;&lt;<span class="keyword">init</span>&gt;()V</span><br><span class="line"></span><br><span class="line">.line <span class="number">10</span></span><br><span class="line">.local v0, <span class="string">&quot;context&quot;</span>:Landroid/content/Context;</span><br><span class="line"><span class="comment">//将字符串&quot;window&quot;赋值给寄存器v1</span></span><br><span class="line"><span class="keyword">const</span>-string v1, <span class="string">&quot;window&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用v0寄存器中的值的getSystemService(String)方法，参数内容是v1寄存器内的值</span></span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, Landroid/content/Context;-&gt;getSystemService(Ljava/lang/String;)Ljava/lang/Object;</span><br><span class="line"><span class="comment">//前一个方法调用的返回值存储到寄存器 v1 中。</span></span><br><span class="line">move-result-<span class="keyword">object</span> v1</span><br><span class="line"></span><br><span class="line">.line <span class="number">11</span></span><br><span class="line">.local v1, <span class="string">&quot;systemService&quot;</span>:Ljava/lang/Object;</span><br><span class="line"><span class="keyword">return</span>-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>



<h6 id="分析字节码-2"><a href="#分析字节码-2" class="headerlink" title="分析字节码-2"></a><em>分析字节码-2</em></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">void a()&#123;</span><br><span class="line">    Context context= new Activity();</span><br><span class="line">    <span class="comment">//调用静态方法</span></span><br><span class="line">    Object systemService = Hook.hook(context,Context.WINDOW_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为上面a函数的字节码</span></span><br><span class="line"></span><br><span class="line">.method a()V</span><br><span class="line">.registers <span class="number">3</span></span><br><span class="line"></span><br><span class="line">.line <span class="number">9</span></span><br><span class="line"><span class="comment">//调用Activity()方法，将返回值放进v0寄存器中</span></span><br><span class="line">new-instance v0, Landroid/app/Activity;</span><br><span class="line"><span class="comment">//调用v0寄存器中的实例对象的init方法</span></span><br><span class="line">invoke-direct &#123;v0&#125;, Landroid/app/Activity;-&gt;&lt;<span class="keyword">init</span>&gt;()V</span><br><span class="line"></span><br><span class="line">.line <span class="number">10</span></span><br><span class="line">.local v0, <span class="string">&quot;context&quot;</span>:Landroid/content/Context;</span><br><span class="line"><span class="comment">//将字符串&quot;window&quot;赋值给寄存器v1</span></span><br><span class="line"><span class="keyword">const</span>-string v1, <span class="string">&quot;window&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用静态方法hook，参数内容是（v0寄存器内的值，v1寄存器内的值）</span></span><br><span class="line">invoke-static &#123;v0, v1&#125;, Lcom/test/Hook;-&gt;hook(Landroid/content/Context;Ljava/lang/String;)Ljava/lang/Object;</span><br><span class="line"><span class="comment">//前一个方法调用的返回值存储到寄存器 v1 中。</span></span><br><span class="line">move-result-<span class="keyword">object</span> v1</span><br><span class="line"></span><br><span class="line">.line <span class="number">11</span></span><br><span class="line">.local v1, <span class="string">&quot;systemService&quot;</span>:Ljava/lang/Object;</span><br><span class="line"><span class="keyword">return</span>-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>



<p><strong>可以看出  invoke-virtual {v0, v1}  和 invoke-static {v0, v1} 主要的区别是</strong>:</p>
<ol>
<li><strong>invoke-virtual 中的v0是作为实例对象的寄存器。相当于 –》  v0.fun( v1 )</strong></li>
<li><strong>invoke-static 中的v0是作为参数的寄存器。相当于 –》  fun( v0 , v1 )</strong></li>
</ol>
<p><strong>一个invoke-virtual场景下的函数调用，操作栈中一定有1+参数个数个变量</strong></p>
<p><strong>一个invoke-static场景下的函数调用，操作栈中只有参数个数个变量</strong></p>
<p>回头看一下第一步的Hook代码，我们将invoke-virtual场景下的函数调用替换成invoke-static调用，所以hook类的静态函数必须多出一个参数来承接 <em><strong>实例对象变量</strong></em></p>
<h2 id="3-再看一下两个场景下的ASM码"><a href="#3-再看一下两个场景下的ASM码" class="headerlink" title="3.再看一下两个场景下的ASM码"></a>3.再看一下两个场景下的ASM码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">Context context= <span class="keyword">new</span> <span class="title class_">Activity</span>();</span><br><span class="line"><span class="comment">//调用实例方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">systemService</span> <span class="operator">=</span> context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为ASM码</span></span><br><span class="line">methodVisitor = classWriter.visitMethod(<span class="number">0</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">methodVisitor.visitCode();</span><br><span class="line">methodVisitor.visitTypeInsn(NEW, <span class="string">&quot;android/app/Activity&quot;</span>);</span><br><span class="line">methodVisitor.visitInsn(DUP);</span><br><span class="line">methodVisitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;android/app/Activity&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ASTORE, <span class="number">1</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">methodVisitor.visitLdcInsn(<span class="string">&quot;window&quot;</span>);</span><br><span class="line"><span class="comment">//Hook点，Hook前的代码</span></span><br><span class="line">methodVisitor.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;android/content/Context&quot;</span>, <span class="string">&quot;getSystemService&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Object;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ASTORE, <span class="number">2</span>);</span><br><span class="line">methodVisitor.visitInsn(RETURN);</span><br><span class="line">methodVisitor.visitMaxs(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">methodVisitor.visitEnd();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    Context context= <span class="keyword">new</span> <span class="title class_">Activity</span>();</span><br><span class="line">    <span class="comment">//调用静态方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">systemService</span> <span class="operator">=</span> Hook.hook(context,Context.WINDOW_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodVisitor = classWriter.visitMethod(<span class="number">0</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">methodVisitor.visitCode();</span><br><span class="line">methodVisitor.visitTypeInsn(NEW, <span class="string">&quot;android/app/Activity&quot;</span>);</span><br><span class="line">methodVisitor.visitInsn(DUP);</span><br><span class="line">methodVisitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;android/app/Activity&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ASTORE, <span class="number">1</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">methodVisitor.visitLdcInsn(<span class="string">&quot;window&quot;</span>);</span><br><span class="line"><span class="comment">//Hook点，Hook后的代码</span></span><br><span class="line">methodVisitor.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;com/Hook&quot;</span>, <span class="string">&quot;hook&quot;</span>, <span class="string">&quot;(Landroid/content/Context;Ljava/lang/String;)Ljava/lang/Object;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">methodVisitor.visitVarInsn(ASTORE, <span class="number">2</span>);</span><br><span class="line">methodVisitor.visitInsn(RETURN);</span><br><span class="line">methodVisitor.visitMaxs(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">methodVisitor.visitEnd();</span><br></pre></td></tr></table></figure>







<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ASM</tag>
        <tag>HOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>Comparator知识点</title>
    <url>/post/c4311606.html</url>
    <content><![CDATA[<h2 id="1-Comparator接口-compare方法实现返回值探究"><a href="#1-Comparator接口-compare方法实现返回值探究" class="headerlink" title="1.Comparator接口  compare方法实现返回值探究"></a>1.Comparator接口  compare方法实现返回值探究</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object : Comparator&lt;Object&gt;() &#123;</span><br><span class="line">            override fun <span class="title function_">compare</span><span class="params">(o1: Object?, o2: Object?)</span>: Int &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">01.</span>xxx -<span class="number">02.</span>xxx</span><br></pre></td></tr></table></figure>

<p>代表着升序队列，xx属性越小的排在越前面 ，适用场景</p>
<ol>
<li>xxx属性代表着进场顺序，而队列需要FIFO </li>
<li>xxx属性代表着创建时间，而队列需要先创建先出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">02.</span>xxx -<span class="number">01.</span>xxx</span><br></pre></td></tr></table></figure>

<p>代表着降序队列，xx属性越大的排在越前面 ，适用场景</p>
<ol>
<li>xxx属性代表着优先级，而队列是高优先级队列</li>
</ol>
<span id="more"></span>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Comparator</tag>
      </tags>
  </entry>
  <entry>
    <title>DialogFragment知识点</title>
    <url>/post/6b67b819.html</url>
    <content><![CDATA[<h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-03-10 14:19:10.971 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onAttach</span><br><span class="line">2019-03-10 14:19:10.971 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onCreate</span><br><span class="line">2019-03-10 14:19:10.972 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onCreateDialog</span><br><span class="line">2019-03-10 14:19:10.972 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onCreateView</span><br><span class="line">2019-03-10 14:19:10.994 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onActivityCreated</span><br><span class="line">2019-03-10 14:19:11.186 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onStart</span><br><span class="line">2019-03-10 14:19:11.186 22626-22626/org.lym.sourcecodeparse D/DialogFragment: onResume</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h2 id="2-关键点"><a href="#2-关键点" class="headerlink" title="2.关键点"></a>2.关键点</h2><h6 id="requestFeature方法必须在onCreateView方法之前调用"><a href="#requestFeature方法必须在onCreateView方法之前调用" class="headerlink" title="requestFeature方法必须在onCreateView方法之前调用"></a>requestFeature方法必须在onCreateView方法之前调用</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">     <span class="keyword">val</span> dialog = <span class="keyword">super</span>.onCreateDialog(savedInstanceState)</span><br><span class="line">     dialog.window?.apply &#123;</span><br><span class="line">         requestFeature(Window.FEATURE_NO_TITLE)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dialog</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<h6 id="setLayout，setGravity等改变UI的方法必须在onStart中调用，不能在onCreateDialog中调用"><a href="#setLayout，setGravity等改变UI的方法必须在onStart中调用，不能在onCreateDialog中调用" class="headerlink" title="setLayout，setGravity等改变UI的方法必须在onStart中调用，不能在onCreateDialog中调用"></a>setLayout，setGravity等改变UI的方法必须在onStart中调用，不能在onCreateDialog中调用</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Window类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLayout</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">attrs</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    attrs.width = width;</span><br><span class="line">    attrs.height = height;</span><br><span class="line">    dispatchWindowAttributesChanged(attrs); <span class="comment">//下发attrs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dialog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onWindowAttributesChanged</span><span class="params">(WindowManager.LayoutParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor != <span class="literal">null</span>) &#123; <span class="comment">//这里的判断是关键</span></span><br><span class="line">        mWindowManager.updateViewLayout(mDecor, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出setLayout等方法必须在mDecor有值时调用才有效，在onCreateDialog方法被调用时mDecor为null，无法进行UI的设置</p>
<h6 id="dialog不拦截区域外的点击事件"><a href="#dialog不拦截区域外的点击事件" class="headerlink" title="dialog不拦截区域外的点击事件"></a>dialog不拦截区域外的点击事件</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setFlags( WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL)</span><br></pre></td></tr></table></figure>



<h5 id="DialogFragment制作的Toast模板：-可以出现在dialog之上，且不影响Activity的点击事件"><a href="#DialogFragment制作的Toast模板：-可以出现在dialog之上，且不影响Activity的点击事件" class="headerlink" title="DialogFragment制作的Toast模板：(可以出现在dialog之上，且不影响Activity的点击事件)"></a><strong>DialogFragment制作的Toast模板：(可以出现在dialog之上，且不影响Activity的点击事件)</strong></h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyToast</span> : <span class="type">DialogFragment</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyToast&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> dialog = MyToast()</span><br><span class="line">            dialog.arguments = Bundle().apply &#123;</span><br><span class="line">                putInt(<span class="string">&quot;value&quot;</span>, value)</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.show(fm , <span class="string">&quot;Tosat&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.view, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        <span class="keyword">val</span> dialog = <span class="keyword">super</span>.onCreateDialog(savedInstanceState)</span><br><span class="line">        dialog.window?.apply &#123; <span class="comment">//去除title样式,必须写在onViewCreated之前</span></span><br><span class="line">            requestFeature(Window.FEATURE_NO_TITLE)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dialog</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        dialog?.window?.apply &#123;</span><br><span class="line">            <span class="comment">//去除灰色背景</span></span><br><span class="line">            clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND)</span><br><span class="line">            <span class="comment">//传递点击事件到Activity</span></span><br><span class="line">            setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL)</span><br><span class="line">            <span class="comment">//背景</span></span><br><span class="line">            setBackgroundDrawable(ColorDrawable(<span class="number">0x00000000</span>))</span><br><span class="line">            <span class="comment">//设置宽高</span></span><br><span class="line">            setLayout(<span class="number">250.</span>dpInt, WindowManager.LayoutParams.WRAP_CONTENT)</span><br><span class="line">            <span class="comment">//位置</span></span><br><span class="line">            setGravity(Gravity.CENTER)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不可取消</span></span><br><span class="line">        isCancelable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//处理逻辑</span></span><br><span class="line">        <span class="comment">//启动定时器调用dismissWithAlpha</span></span><br><span class="line">        lifecycleScope.launch &#123; </span><br><span class="line">            delay(<span class="number">3000</span>)</span><br><span class="line">            dismissWithAlpha()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dismissWithAlpha</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(view, <span class="string">&quot;alpha&quot;</span>, <span class="number">1.0f</span>, <span class="number">0f</span>)</span><br><span class="line">        animator.duration = <span class="number">320</span></span><br><span class="line">        animator.doOnEnd &#123;</span><br><span class="line">           <span class="keyword">if</span> (fragmentManager != <span class="literal">null</span>) &#123; </span><br><span class="line">               <span class="comment">//加个null判断 因为有个定时器逻辑，最容易发生 Fragment not associated with a fragment manager.</span></span><br><span class="line">                dismissAllowingStateLoss()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        animator?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>DialogFragment</tag>
      </tags>
  </entry>
  <entry>
    <title>Flow知识点</title>
    <url>/post/58bbdd0e.html</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6989536876096913439">【Kotlin Flow】 一眼看全——Flow操作符大全</a></p>
<h1 id="1-Flow-的collect的正常用法"><a href="#1-Flow-的collect的正常用法" class="headerlink" title="1.Flow 的collect的正常用法"></a>1.Flow 的collect的正常用法</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mainScope.launch &#123;</span><br><span class="line">    flow.collect &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mainScope.launch &#123;</span><br><span class="line">    flow2.collect &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> flow的collect是个suspend函数，内部逻辑是个while(true)死循环，所以不能在collect之后写任何代码，因为执行不到 </p>
<span id="more"></span>



<p>下面为 <strong>SharedFlowImpl</strong> 的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override suspend fun collect(collector: FlowCollector&lt;T&gt;): Nothing &#123;</span><br><span class="line">    val slot = allocateSlot()</span><br><span class="line">    try &#123;</span><br><span class="line">        if (collector is SubscribedFlowCollector) collector.onSubscription()</span><br><span class="line">        val collectorJob = currentCoroutineContext()[Job]</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            var newValue: Any?</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                newValue = tryTakeValue(slot) // attempt no-suspend fast path first</span><br><span class="line">                if (newValue !== NO_VALUE) break</span><br><span class="line">                awaitValue(slot) // await signal that the new value is available</span><br><span class="line">            &#125;</span><br><span class="line">            collectorJob?.ensureActive()</span><br><span class="line">            collector.emit(newValue as T)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        freeSlot(slot)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><font color='red'>如果需要collect一个flow，需要单独起一个协程，该协程内只能collect一个flow，不能在collect函数后面加任何代码</font></p>
<h1 id="2-zip操作符和combine操作符区别"><a href="#2-zip操作符和combine操作符区别" class="headerlink" title="2.zip操作符和combine操作符区别"></a>2.<em>zip</em>操作符和<em>combine</em>操作符区别</h1><ol>
<li><p>zip要求 ：两个流发送数据的次数必须一致，1+1 合并成新的数据</p>
<p>​     如果A流发两个数据，B流发一个数据，则A流的第二个数据因为找不到B流的对应数据，不会触发zip流的合并发送</p>
</li>
<li><p>combine要求：没啥要求，两个流任意一个流的数据刷新，combine流都会取两个流的最新值进行合并</p>
</li>
</ol>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment知识点</title>
    <url>/post/1733ce00.html</url>
    <content><![CDATA[<h2 id="1-关键节点"><a href="#1-关键节点" class="headerlink" title="1.关键节点"></a>1.关键节点</h2><p>Fragment调用生命周期最近的方法</p>
<p>androidx.fragment.app.FragmentStateManager#moveToExpectedState</p>
<span id="more"></span>



<h2 id="2-Commit与CommitNow的区别"><a href="#2-Commit与CommitNow的区别" class="headerlink" title="2.Commit与CommitNow的区别"></a>2.Commit与CommitNow的区别</h2><ol>
<li><p>commit() &gt;&gt; enqueueAction() &gt;&gt; scheduleCommit() &gt;&gt; execPendingActions()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleCommit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">postponeReady</span> <span class="operator">=</span></span><br><span class="line">            mPostponedTransactions != <span class="literal">null</span> &amp;&amp; !mPostponedTransactions.isEmpty();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">pendingReady</span> <span class="operator">=</span> mPendingActions != <span class="literal">null</span> &amp;&amp; mPendingActions.size() == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (postponeReady || pendingReady) &#123;</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">            mHost.getHandler().post(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​       </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">mExecCommit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到commit方法利用Handler机制， 是异步的，所以不清楚fragment什么时候被添加上，不清楚生命周期什么时候被调用</p>
<p>2.commitNow() &gt;&gt;  execSingleAction() &gt;&gt;  removeRedundantOperationsAndExecute() &gt;&gt; executeOpsTogether()</p>
<p>删除部分代码，贴入executeOpsTogether重要部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((newState = <span class="built_in">this</span>.computeExpectedState()) != <span class="built_in">this</span>.mFragment.mState) &#123;</span><br><span class="line">                 stateWasChanged = <span class="literal">true</span>;</span><br><span class="line">                 <span class="type">int</span> nextStep;</span><br><span class="line">                 <span class="keyword">if</span> (newState &gt; <span class="built_in">this</span>.mFragment.mState) &#123;</span><br><span class="line">                     nextStep = <span class="built_in">this</span>.mFragment.mState + <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">switch</span> (nextStep) &#123;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                             <span class="built_in">this</span>.attach();</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                             <span class="built_in">this</span>.create();</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                             <span class="built_in">this</span>.ensureInflatedView();</span><br><span class="line">                             <span class="built_in">this</span>.createView();</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                             <span class="built_in">this</span>.activityCreated();</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                             <span class="built_in">this</span>.mFragment.mState = <span class="number">4</span>;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                             <span class="built_in">this</span>.start();</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                             <span class="built_in">this</span>.mFragment.mState = <span class="number">6</span>;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                             <span class="built_in">this</span>.resume();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到commitNow 是同步的，连同Fragment的各个生命周期OnCreate，OnCreateView都会在同一个Looper消息循环中被调用</p>
<p>因此在一些迫切需要立刻展示的场景，可以使用commitNow 或者 commitNowAllowingStateLoss</p>
<h2 id="3-Fragment-onResume调用时，view的WindowToken是空的吗？"><a href="#3-Fragment-onResume调用时，view的WindowToken是空的吗？" class="headerlink" title="3.Fragment onResume调用时，view的WindowToken是空的吗？"></a>3.Fragment onResume调用时，view的WindowToken是空的吗？</h2><p> <em>答案：不一定，如果activity的window没在屏幕上时，那么token就是空的；如果是activity的window已经在屏幕上时，再创建显示一个fragment，此时token就不是空的</em></p>
<h5 id="Fragment是在Activity的onCreate方法时加入场景下-Fragment的onResume方法调用路径"><a href="#Fragment是在Activity的onCreate方法时加入场景下-Fragment的onResume方法调用路径" class="headerlink" title="Fragment是在Activity的onCreate方法时加入场景下 , Fragment的onResume方法调用路径"></a>Fragment是在Activity的onCreate方法时加入场景下 , Fragment的onResume方法调用路径</h5><p><img src="https://s3.bmp.ovh/imgs/2023/06/12/3dd9a65d555145c1.jpg"></p>
<p>可以看到 Fragment的onResume是在同一个消息循环中，跟着Activity的onResume方法调用的，</p>
<p>我们都知道Activity的onResume方法调用，activity的view是还没有add到window上的，所以导致fragment的view有没有add到window上，没有token</p>
<h5 id="Fragment-的view是什么时候add的？"><a href="#Fragment-的view是什么时候add的？" class="headerlink" title="Fragment 的view是什么时候add的？"></a>Fragment 的view是什么时候add的？</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FragmentStateManager类</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createView</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.mFragment.mContainer = container;</span><br><span class="line">    <span class="comment">//Fragment的onCreateView被调用</span></span><br><span class="line">    <span class="built_in">this</span>.mFragment.performCreateView(layoutInflater, container, <span class="built_in">this</span>.mFragment.mSavedFragmentState);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mFragment.mView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mFragment.mView.setSaveFromParentEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">this</span>.mFragment.mView.setTag(id.fragment_container_view_tag, <span class="built_in">this</span>.mFragment);</span><br><span class="line">        <span class="keyword">if</span> (container != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加入父布局</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.mFragmentStore.findFragmentIndexInContainer(<span class="built_in">this</span>.mFragment);</span><br><span class="line">            <span class="built_in">this</span>.mFragment.mContainer.addView(<span class="built_in">this</span>.mFragment.mView, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Fragment的onViewCreated被调用</span></span><br><span class="line">        <span class="built_in">this</span>.mFragment.performViewCreated();</span><br><span class="line">        <span class="built_in">this</span>.mDispatcher.dispatchOnFragmentViewCreated(<span class="built_in">this</span>.mFragment, <span class="built_in">this</span>.mFragment.mView, <span class="built_in">this</span>.mFragment.mSavedFragmentState, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到虽然Fragment 的view在createView时就add到mContainer上，但可惜mContainer还没有add到window上，所以导致一直到onResume时，也拿不到token</p>
<p>知识场景：Fragment onResume调用时，利用fragment的view 显示一个popupwindow可能会因为拿不到token导致崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure>



<p>解决方法：post一下再显示popupwindow</p>
<h2 id="探究activity-onCreate方法中-commit-fragment-场景下，fragment的生命周期"><a href="#探究activity-onCreate方法中-commit-fragment-场景下，fragment的生命周期" class="headerlink" title="探究activity onCreate方法中 commit fragment 场景下，fragment的生命周期"></a>探究activity onCreate方法中 commit fragment 场景下，fragment的生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FragmentActivity类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mFragments.noteStateNotSaved();</span><br><span class="line">    <span class="built_in">super</span>.onStart();</span><br><span class="line">    <span class="built_in">this</span>.mStopped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.mCreated) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mCreated = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.mFragments.dispatchActivityCreated();  <span class="comment">//this.dispatchStateChange(4);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.mFragments.execPendingActions();</span><br><span class="line">    <span class="built_in">this</span>.mFragmentLifecycleRegistry.handleLifecycleEvent(Event.ON_START);</span><br><span class="line">    <span class="built_in">this</span>.mFragments.dispatchStart(); <span class="comment">// this.dispatchStateChange(5);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FragmentStateManager类</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">moveToExpectedState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newState &gt; <span class="built_in">this</span>.mFragment.mState) &#123;</span><br><span class="line">        nextStep = <span class="built_in">this</span>.mFragment.mState + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(nextStep) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">this</span>.attach();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">this</span>.create();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">this</span>.ensureInflatedView();</span><br><span class="line">                <span class="built_in">this</span>.createView();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">this</span>.activityCreated();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">this</span>.mFragment.mState = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">this</span>.start();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">this</span>.mFragment.mState = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">this</span>.resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到除了fragment的onResume方法外，所有创建的生命周期都在Activity的onStart()中被调用。</p>
<p>其实Activity的onCreate方法也会调用this.dispatchStateChange(1)，但我们的场景onCreate被调用时才进行commit，导致此时还没有任何的fragment。所有都生命周期堆积在Activity的onStart()中被调用</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>ImageSpan扩展</title>
    <url>/post/503d328.html</url>
    <content><![CDATA[<h2 id="支持GIF播放的TextView"><a href="#支持GIF播放的TextView" class="headerlink" title="支持GIF播放的TextView"></a>支持GIF播放的TextView</h2><span id="more"></span>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpanTextView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyle: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : TextView(context, attrs, defStyle) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> hasSpanCallback = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isSpanAttached = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> spanCallbacks: Array&lt;SpanCallback&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow()</span><br><span class="line">        onAttach()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow()</span><br><span class="line">        onDetach()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartTemporaryDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStartTemporaryDetach()</span><br><span class="line">        onDetach()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinishTemporaryDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishTemporaryDetach()</span><br><span class="line">        onAttach()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setText</span><span class="params">(text: <span class="type">CharSequence</span>, type: <span class="type">BufferType</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getText() === text) &#123;</span><br><span class="line">            <span class="comment">//防止重复设置text导致span中反复调用生命周期方法</span></span><br><span class="line">            <span class="keyword">super</span>.setText(text, type)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> wasSpanAttached = isSpanAttached</span><br><span class="line">        <span class="keyword">if</span> (hasSpanCallback &amp;&amp; wasSpanAttached) &#123;</span><br><span class="line">            onDetach()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text <span class="keyword">is</span> Spanned) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                spanCallbacks = text.getSpans(<span class="number">0</span>, text.length, SpanCallback::<span class="keyword">class</span>.java)</span><br><span class="line">                hasSpanCallback = spanCallbacks?.isNotEmpty() == <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: ArrayIndexOutOfBoundsException) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spanCallbacks = <span class="literal">null</span></span><br><span class="line">            hasSpanCallback = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.setText(text, type)</span><br><span class="line">        <span class="keyword">if</span> (hasSpanCallback &amp;&amp; wasSpanAttached) &#123;</span><br><span class="line">            onAttach()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        spanCallbacks?.forEach &#123;</span><br><span class="line">            it.onAttach(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        isSpanAttached = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        spanCallbacks?.forEach &#123;</span><br><span class="line">            it.onDetach()</span><br><span class="line">        &#125;</span><br><span class="line">        isSpanAttached = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">SpanCallback</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(textView: <span class="type">TextView</span>)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="支持GIF的ImageSpan"><a href="#支持GIF的ImageSpan" class="headerlink" title="支持GIF的ImageSpan"></a>支持GIF的ImageSpan</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GIFImageSpan</span>(d: Drawable) : CustomImageSpan(d) , SpanTextView.SpanCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curDrawableCallback: Drawable.Callback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(textView: <span class="type">TextView</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> textViewRef = WeakReference(textView)</span><br><span class="line">        (drawable <span class="keyword">as</span>? GifDrawable)?.apply &#123;</span><br><span class="line">            curDrawableCallback = <span class="keyword">object</span> : Drawable.Callback &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invalidateDrawable</span><span class="params">(who: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">                    textViewRef.<span class="keyword">get</span>()?.invalidate()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>, `<span class="keyword">when</span>`: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">unscheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            drawable.callback = curDrawableCallback</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">                start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        (drawable <span class="keyword">as</span>? GifDrawable)?.apply &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curDrawableCallback = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>扩展点</category>
      </categories>
      <tags>
        <tag>ImageSpan</tag>
      </tags>
  </entry>
  <entry>
    <title>PopUpWindow知识点</title>
    <url>/post/p8hxlm47.html</url>
    <content><![CDATA[<h2 id="PopUpWindow基础用法"><a href="#PopUpWindow基础用法" class="headerlink" title="PopUpWindow基础用法"></a>PopUpWindow基础用法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承PopupWindow</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPopupWindow</span>(context: Context) : PopupWindow(context) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))</span><br><span class="line">        contentView = view</span><br><span class="line">        width = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        height = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showAtLocation(parent, Gravity.CENTER, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h4 id="问题1：丢失contentView设置的宽度"><a href="#问题1：丢失contentView设置的宽度" class="headerlink" title="问题1：丢失contentView设置的宽度"></a>问题1：丢失contentView设置的宽度</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PopupWindow</span></span><br><span class="line"><span class="keyword">private</span> void preparePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackground != <span class="literal">null</span>) &#123; <span class="comment">//背景图不为空，将创建背景View</span></span><br><span class="line">        mBackgroundView = createBackgroundView(mContentView);</span><br><span class="line">        mBackgroundView.setBackground(mBackground);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//不设置背景图时，contentView就是背景View</span></span><br><span class="line">        mBackgroundView = mContentView;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecorView = createDecorView(mBackgroundView);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将contentView加入背景ViewGroud中</span></span><br><span class="line"><span class="comment">//如果设置的contentView的高是WRAP_CONTENT，将不改变contentView的高</span></span><br><span class="line"><span class="comment">//否则将contentView的高以MATCH_PARENT加入背景ViewGroud中</span></span><br><span class="line"><span class="comment">//而宽度锁死为MATCH_PARENT</span></span><br><span class="line"><span class="keyword">private</span> PopupBackgroundView createBackgroundView(View contentView) &#123;</span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> int height;</span><br><span class="line">    <span class="keyword">if</span> (layoutParams != <span class="literal">null</span> &amp;&amp; layoutParams.height == WRAP_CONTENT) &#123;</span><br><span class="line">        height = WRAP_CONTENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        height = MATCH_PARENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> PopupBackgroundView backgroundView = new PopupBackgroundView(mContext);</span><br><span class="line">    <span class="keyword">final</span> PopupBackgroundView.LayoutParams listParams = new PopupBackgroundView.LayoutParams(</span><br><span class="line">        MATCH_PARENT, height);</span><br><span class="line">    backgroundView.addView(contentView, listParams);</span><br><span class="line">    <span class="keyword">return</span> backgroundView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将背景View加入DecorView中</span></span><br><span class="line"><span class="comment">//如果设置的contentView的高是WRAP_CONTENT，背景View的高也是WRAP_CONTENT</span></span><br><span class="line"><span class="comment">//否则将背景View的高将以MATCH_PARENT加入背景ViewGroud中</span></span><br><span class="line"><span class="comment">//而背景View宽度锁死为MATCH_PARENT</span></span><br><span class="line"><span class="keyword">private</span> PopupDecorView createDecorView(View contentView) &#123;</span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> int height;</span><br><span class="line">    <span class="keyword">if</span> (layoutParams != <span class="literal">null</span> &amp;&amp; layoutParams.height == WRAP_CONTENT) &#123;</span><br><span class="line">        height = WRAP_CONTENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        height = MATCH_PARENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PopupDecorView decorView = new PopupDecorView(mContext);</span><br><span class="line">    decorView.addView(contentView, MATCH_PARENT, height);</span><br><span class="line">    decorView.setClipChildren(<span class="literal">false</span>);</span><br><span class="line">    decorView.setClipToPadding(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DecorView将以设置PopupWindow的宽高加入window中 </span></span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>宽度：</p>
<ol>
<li>背景View 宽度  MATCH_PARENT</li>
<li>contentView宽度  MATCH_PARENT</li>
</ol>
<p>高度：</p>
<p>如果 contentView高度 是  WRAP_CONTENT </p>
<ol>
<li>contentView高度 是  WRAP_CONTENT</li>
<li>​     背景View高度 是  WRAP_CONTENT</li>
</ol>
<p>否则</p>
<ol>
<li>​    contentView高度 是  MATCH_PARENT</li>
<li>​    背景View高度 是  MATCH_PARENT</li>
</ol>
<p><strong>由上面可以看出，contentView宽度数据被完全丢失，因此如果contentView存在具体的宽度数据，必须挪到PopupWindow的宽度属性上</strong></p>
<h4 id="提问：当PopupWindow的宽度设置为WRAP-CONTENT-，而我们知道contentView的宽度锁死为MATCH-PARENT，那弹窗的宽度是什么呢？"><a href="#提问：当PopupWindow的宽度设置为WRAP-CONTENT-，而我们知道contentView的宽度锁死为MATCH-PARENT，那弹窗的宽度是什么呢？" class="headerlink" title="提问：当PopupWindow的宽度设置为WRAP_CONTENT ，而我们知道contentView的宽度锁死为MATCH_PARENT，那弹窗的宽度是什么呢？"></a>提问：当PopupWindow的宽度设置为WRAP_CONTENT ，而我们知道contentView的宽度锁死为MATCH_PARENT，那弹窗的宽度是什么呢？</h4><p>做个实验便知道：PopupWindow宽是WRAP_CONTENT -》DecorView的宽是WRAP_CONTENT </p>
<p>FrameLayout宽是WRAP_CONTENT ，而它子View（ConstraintLayout）是MATCH_PARENT时，子View（ConstraintLayout）的宽度将是WRAP_CONTENT的形式展示。</p>
<h2 id="PopupWindow如何全屏"><a href="#PopupWindow如何全屏" class="headerlink" title="PopupWindow如何全屏"></a>PopupWindow如何全屏</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))</span><br><span class="line">isFocusable = <span class="literal">true</span> <span class="comment">//为了支持返回键响应</span></span><br><span class="line">isClippingEnabled = <span class="literal">false</span> <span class="comment">//为了覆盖到状态栏</span></span><br><span class="line">width = ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">height = ViewGroup.LayoutParams.MATCH_PARENT</span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>PopUpWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>MAT使用技巧</title>
    <url>/post/4f06ab99.html</url>
    <content><![CDATA[<h2 id="1-MAT打开报错-MemoryAnalyzer指定JDK版本"><a href="#1-MAT打开报错-MemoryAnalyzer指定JDK版本" class="headerlink" title="1.MAT打开报错    MemoryAnalyzer指定JDK版本"></a>1.MAT打开报错    <a href="https://blog.csdn.net/epitomizelu/article/details/118294432">MemoryAnalyzer指定JDK版本</a></h2><h2 id="2-Hprof-转为MAT能读取的格式-Android-studio导出hprof到MAT工具流程"><a href="#2-Hprof-转为MAT能读取的格式-Android-studio导出hprof到MAT工具流程" class="headerlink" title="2.Hprof 转为MAT能读取的格式 Android studio导出hprof到MAT工具流程"></a>2.Hprof 转为MAT能读取的格式 <a href="https://blog.csdn.net/tangedegushi/article/details/83015612">Android studio导出hprof到MAT工具流程</a></h2><h2 id="3-对比多个Hprof文件-使用MAT比较多个hprof文件"><a href="#3-对比多个Hprof文件-使用MAT比较多个hprof文件" class="headerlink" title="3.对比多个Hprof文件 使用MAT比较多个hprof文件"></a>3.对比多个Hprof文件 <a href="https://blog.csdn.net/mldxs/article/details/89349044">使用MAT比较多个hprof文件</a></h2><span id="more"></span>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>使用技巧</category>
      </categories>
      <tags>
        <tag>MAT</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView首次加载图片展示完成时机</title>
    <url>/post/94cfd8e0.html</url>
    <content><![CDATA[<p>突然接到一个需求，要知道一个RecyclerView刚打开时，第一次加载时屏幕上所有子item的封面图片下载完成的时机</p>
<span id="more"></span>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-目前屏幕上RecyclerView所有可见viewHolder"><a href="#1-目前屏幕上RecyclerView所有可见viewHolder" class="headerlink" title="1.目前屏幕上RecyclerView所有可见viewHolder"></a>1.目前屏幕上RecyclerView所有可见viewHolder</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> manager =recyclerview.layoutManager()</span><br><span class="line"><span class="keyword">val</span> first = findFirstVisibleItemPosition()</span><br><span class="line"><span class="keyword">val</span> last = findLastVisibleItemPosition()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> first..last) &#123;</span><br><span class="line">    <span class="keyword">val</span> viewHolder = recyclerView?.findViewHolderForAdapterPosition(i) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-图片下载完成时机（Glide）"><a href="#2-图片下载完成时机（Glide）" class="headerlink" title="2.图片下载完成时机（Glide）"></a>2.图片下载完成时机（Glide）</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Glide.with(coverView).load(item.cover).into(<span class="keyword">object</span> : DrawableImageViewTarget(coverView) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setResource</span><span class="params">(resource: <span class="type">Drawable</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setResource(resource)</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此时已完成图片展示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="3-最重要的是知道什么时候调用第一步，获得Recyclerview第一次加载完成后屏幕上所有可见viewHolder"><a href="#3-最重要的是知道什么时候调用第一步，获得Recyclerview第一次加载完成后屏幕上所有可见viewHolder" class="headerlink" title="3.最重要的是知道什么时候调用第一步，获得Recyclerview第一次加载完成后屏幕上所有可见viewHolder"></a>3.最重要的是知道什么时候调用第一步，获得Recyclerview第一次加载完成后屏幕上所有可见viewHolder</h3><h6 id="答案是-自定义GridLayoutManager-，重写onLayoutCompleted方法"><a href="#答案是-自定义GridLayoutManager-，重写onLayoutCompleted方法" class="headerlink" title="答案是 自定义GridLayoutManager ，重写onLayoutCompleted方法"></a>答案是 自定义GridLayoutManager ，重写onLayoutCompleted方法</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGridLayoutManager</span>(context: Context?, spanSize: <span class="built_in">Int</span>) : GridLayoutManager(context, spanSize) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">//是否已经是首次加载</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> isAlreadyRecordCover = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> recyclerView: RecyclerView? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> coverUrls = mutableListOf&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToWindow</span><span class="params">(view: <span class="type">RecyclerView</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow(view)</span><br><span class="line">        recyclerView = view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//该方法被调用时，已完成布局，结合自定义变量isAlreadyRecordCover，实现获得第一次加载的数据</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutCompleted</span><span class="params">(state: <span class="type">RecyclerView</span>.<span class="type">State</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayoutCompleted(state)</span><br><span class="line">        <span class="keyword">if</span> (isAlreadyRecordCover) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> first = findFirstVisibleItemPosition()</span><br><span class="line">        <span class="keyword">val</span> last = findLastVisibleItemPosition()</span><br><span class="line">        <span class="keyword">if</span> (first != -<span class="number">1</span> &amp;&amp; last != -<span class="number">1</span>) &#123; <span class="comment">//不等于-1才说明Recyclerview真的有数据</span></span><br><span class="line">            isAlreadyRecordCover = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> first..last) &#123;</span><br><span class="line">                <span class="keyword">val</span> viewHolder = recyclerView?.findViewHolderForAdapterPosition(i)</span><br><span class="line">                <span class="comment">//通过viewHolder 获得并记录封面url</span></span><br><span class="line">                coverUrls.add(url)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 步骤2的需要通知的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reportCoverShow</span><span class="params">(cover: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coverUrls.contains(cover)) &#123;</span><br><span class="line">            coverUrls.remove(cover)</span><br><span class="line">            <span class="keyword">if</span> (coverUrls.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//此时封面数据已全部展示</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道怎么实现后感觉挺简单的，较难的是想到解决思路</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>RecyclerView首次加载</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkMovementMethod知识点</title>
    <url>/post/p8hxlm4c.html</url>
    <content><![CDATA[<h6 id="LinkMovementMethod问题点："><a href="#LinkMovementMethod问题点：" class="headerlink" title="LinkMovementMethod问题点："></a>LinkMovementMethod问题点：</h6><p>当clickSpan连着imageSpan时，点击imageSpan很容易就触发到clickspan的点击逻辑</p>
<p>特别是文本发生换行时，clickSpan连着imageSpan，此时imagespan处于行尾时，很容易触发该问题</p>
<p><a href="https://www.jianshu.com/p/b87dddf02e04">ImageSpan点击事件位置偏移问题</a></p>
<p> 上面的博客提供了BUG原因和解决方案</p>
<span id="more"></span>



<h2 id="自定义LinkMovementMethod"><a href="#自定义LinkMovementMethod" class="headerlink" title="自定义LinkMovementMethod"></a>自定义LinkMovementMethod</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMovementMethod</span> <span class="keyword">extends</span> <span class="title class_">ScrollingMovementMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CLICK</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UP</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DOWN</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HIDE_FLOATING_TOOLBAR_DELAY_MS</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canSelectArbitrarily</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">handleMovementKey</span><span class="params">(TextView widget, Spannable buffer, <span class="type">int</span> keyCode,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> movementMetaState, KeyEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (keyCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_CENTER:</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_ENTER:</span><br><span class="line">                <span class="keyword">if</span> (KeyEvent.metaStateHasNoModifiers(movementMetaState)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp;</span><br><span class="line">                            event.getRepeatCount() == <span class="number">0</span> &amp;&amp; action(CLICK, widget, buffer)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.handleMovementKey(widget, buffer, keyCode, movementMetaState, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">up</span><span class="params">(TextView widget, Spannable buffer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action(UP, widget, buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.up(widget, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">down</span><span class="params">(TextView widget, Spannable buffer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action(DOWN, widget, buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.down(widget, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">left</span><span class="params">(TextView widget, Spannable buffer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action(UP, widget, buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.left(widget, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">right</span><span class="params">(TextView widget, Spannable buffer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action(DOWN, widget, buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.right(widget, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">action</span><span class="params">(<span class="type">int</span> what, TextView widget, Spannable buffer)</span> &#123;</span><br><span class="line">        <span class="type">Layout</span> <span class="variable">layout</span> <span class="operator">=</span> widget.getLayout();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> widget.getTotalPaddingTop() +</span><br><span class="line">                      widget.getTotalPaddingBottom();</span><br><span class="line">        <span class="type">int</span> <span class="variable">areaTop</span> <span class="operator">=</span> widget.getScrollY();</span><br><span class="line">        <span class="type">int</span> <span class="variable">areaBot</span> <span class="operator">=</span> areaTop + widget.getHeight() - padding;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lineTop</span> <span class="operator">=</span> layout.getLineForVertical(areaTop);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lineBot</span> <span class="operator">=</span> layout.getLineForVertical(areaBot);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> layout.getLineStart(lineTop);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> layout.getLineEnd(lineBot);</span><br><span class="line"></span><br><span class="line">        ClickableSpan[] candidates = buffer.getSpans(first, last, ClickableSpan.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Selection.getSelectionStart(buffer);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Selection.getSelectionEnd(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">selStart</span> <span class="operator">=</span> Math.min(a, b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">selEnd</span> <span class="operator">=</span> Math.max(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer.getSpanStart(FROM_BELOW) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                selStart = selEnd = buffer.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selStart &gt; last)</span><br><span class="line">            selStart = selEnd = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (selEnd &lt; first)</span><br><span class="line">            selStart = selEnd = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CLICK:</span><br><span class="line">                <span class="keyword">if</span> (selStart == selEnd) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ClickableSpan[] links = buffer.getSpans(selStart, selEnd, ClickableSpan.class);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (links.length != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">ClickableSpan</span> <span class="variable">link</span> <span class="operator">=</span> links[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//                if (link instanceof TextLinkSpan) &#123;</span></span><br><span class="line"><span class="comment">//                    ((TextLinkSpan) link).onClick(widget, TextLinkSpan.INVOCATION_METHOD_KEYBOARD);</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    link.onClick(widget);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                link.onClick(widget);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="type">int</span> bestStart, bestEnd;</span><br><span class="line"></span><br><span class="line">                bestStart = -<span class="number">1</span>;</span><br><span class="line">                bestEnd = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> buffer.getSpanEnd(candidates[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (end &lt; selEnd || selStart == selEnd) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (end &gt; bestEnd) &#123;</span><br><span class="line">                            bestStart = buffer.getSpanStart(candidates[i]);</span><br><span class="line">                            bestEnd = end;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bestStart &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Selection.setSelection(buffer, bestEnd, bestStart);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                bestStart = Integer.MAX_VALUE;</span><br><span class="line">                bestEnd = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> buffer.getSpanStart(candidates[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (start &gt; selStart || selStart == selEnd) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (start &lt; bestStart) &#123;</span><br><span class="line">                            bestStart = start;</span><br><span class="line">                            bestEnd = buffer.getSpanEnd(candidates[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bestEnd &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    Selection.setSelection(buffer, bestStart, bestEnd);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(TextView widget, Spannable buffer,</span></span><br><span class="line"><span class="params">                                MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">            x -= widget.getTotalPaddingLeft();</span><br><span class="line">            y -= widget.getTotalPaddingTop();</span><br><span class="line"></span><br><span class="line">            x += widget.getScrollX();</span><br><span class="line">            y += widget.getScrollY();</span><br><span class="line"></span><br><span class="line">            <span class="type">Layout</span> <span class="variable">layout</span> <span class="operator">=</span> widget.getLayout();</span><br><span class="line">            <span class="type">int</span> <span class="variable">line</span> <span class="operator">=</span> layout.getLineForVertical(y);</span><br><span class="line">            <span class="type">int</span> <span class="variable">off</span> <span class="operator">=</span> layout.getOffsetForHorizontal(line, x);</span><br><span class="line">            <span class="comment">//该off所在字符的水平偏移</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">xLeft</span> <span class="operator">=</span> layout.getPrimaryHorizontal(off);</span><br><span class="line">            <span class="keyword">if</span> (xLeft &lt; x) &#123;</span><br><span class="line">                off += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                off -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (links.length != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">ClickableSpan</span> <span class="variable">link</span> <span class="operator">=</span> links[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line"><span class="comment">//                    if (link instanceof TextLinkSpan) &#123;</span></span><br><span class="line"><span class="comment">//                        ((TextLinkSpan) link).onClick(</span></span><br><span class="line"><span class="comment">//                                widget, TextLinkSpan.INVOCATION_METHOD_TOUCH);</span></span><br><span class="line"><span class="comment">//                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                        link.onClick(widget);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    link.onClick(widget);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="comment">//                    if (widget.getContext().getApplicationInfo().targetSdkVersion</span></span><br><span class="line"><span class="comment">//                            &gt;= Build.VERSION_CODES.P) &#123;</span></span><br><span class="line"><span class="comment">//                        // Selection change will reposition the toolbar. Hide it for a few ms for a</span></span><br><span class="line"><span class="comment">//                        // smoother transition.</span></span><br><span class="line"><span class="comment">//                        widget.hideFloatingToolbar(HIDE_FLOATING_TOOLBAR_DELAY_MS);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    Selection.setSelection(buffer,</span><br><span class="line">                            buffer.getSpanStart(link),</span><br><span class="line">                            buffer.getSpanEnd(link));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Selection.removeSelection(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(widget, buffer, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(TextView widget, Spannable text)</span> &#123;</span><br><span class="line">        Selection.removeSelection(text);</span><br><span class="line">        text.removeSpan(FROM_BELOW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTakeFocus</span><span class="params">(TextView view, Spannable text, <span class="type">int</span> dir)</span> &#123;</span><br><span class="line">        Selection.removeSelection(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dir &amp; View.FOCUS_BACKWARD) != <span class="number">0</span>) &#123;</span><br><span class="line">            text.setSpan(FROM_BELOW, <span class="number">0</span>, <span class="number">0</span>, Spannable.SPAN_POINT_POINT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            text.removeSpan(FROM_BELOW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MovementMethod <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>)</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">PublicChatMovementMethod</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PublicChatMovementMethod sInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">FROM_BELOW</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoCopySpan</span>.Concrete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>LinkMovementMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView曝光踩坑-3</title>
    <url>/post/362a61c3.html</url>
    <content><![CDATA[<p><a href="https://lanshushui.github.io/post/22258c7a.html">RecyclerView曝光踩坑-1</a></p>
<p><a href="https://lanshushui.github.io/post/412d5155.html">RecyclerView曝光踩坑-2</a></p>
<p>背景： 使用RecyclerView+PagerSnapHelper 实现一页一页滑动的效果。</p>
<p>使用RecyclerView的smoothScrollToPosition实现自动滑页功能。</p>
<p>当从第一页自动滑向第二页，第二页和第三页的都会被调用onViewAttachedToWindow，导致多余页面上报。</p>
<span id="more"></span>



<h2 id="首先让我们看一下问题场景下的-DEBUG-信息"><a href="#首先让我们看一下问题场景下的-DEBUG-信息" class="headerlink" title="首先让我们看一下问题场景下的 DEBUG 信息"></a>首先让我们看一下问题场景下的 DEBUG 信息</h2><p><img src="https://s3.bmp.ovh/imgs/2023/08/07/5d9ab8ba137383e8.jpg"></p>
<p>LinearLayoutManager的fill函数是布局关键函数，不了解的先去了解一下，这里就不仔细讲了。</p>
<p>remainingSpace是布局可用空间，截图数值为265。是由<strong>【layoutState.mAvailable的1px】和【layoutState.mExtraFillSpace的264px】</strong>组成。</p>
<p><strong>我的用例场景一页宽度就是264px</strong>。所以导致会加载进两个页面，导致问题的出现。</p>
<p>让我们来分析下<strong>【 layoutState.mAvailable的1px】 和 【layoutState.mExtraFillSpace的264px】</strong>   是如何产生的？这有利于我们解决问题</p>
<h2 id="1-分析smoothScrollToPosition实现逻辑"><a href="#1-分析smoothScrollToPosition实现逻辑" class="headerlink" title="1.分析smoothScrollToPosition实现逻辑"></a>1.分析smoothScrollToPosition实现逻辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RecyclerView</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoothScrollToPosition</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">    mLayout.smoothScrollToPosition(<span class="built_in">this</span>, mState, position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinearLayoutManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoothScrollToPosition</span><span class="params">(RecyclerView recyclerView, RecyclerView.State state,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="type">LinearSmoothScroller</span> <span class="variable">linearSmoothScroller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearSmoothScroller</span>(recyclerView.getContext());</span><br><span class="line">    <span class="comment">//设置目标位置</span></span><br><span class="line">    linearSmoothScroller.setTargetPosition(position);</span><br><span class="line">    linearSmoothScroller.start(mRecyclerView, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SmoothScroller</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">(RecyclerView recyclerView, LayoutManager layoutManager)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止上一个mViewFlinger</span></span><br><span class="line">    recyclerView.mViewFlinger.stop();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//google建议我们每一次滑动都创建一个新的SmoothScroller，LinearLayoutManager正是这样子操作的，我们自定义LayoutManger注意一下</span></span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;An instance of &quot;</span> + <span class="built_in">this</span>.getClass().getSimpleName() + <span class="string">&quot; was started &quot;</span></span><br><span class="line">              + <span class="string">&quot;more than once. Each instance of&quot;</span> + <span class="built_in">this</span>.getClass().getSimpleName() + <span class="string">&quot; &quot;</span></span><br><span class="line">              + <span class="string">&quot;is intended to only be used once. You should create a new instance for &quot;</span></span><br><span class="line">              + <span class="string">&quot;each use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRecyclerView = recyclerView;</span><br><span class="line">    mLayoutManager = layoutManager;</span><br><span class="line">    <span class="keyword">if</span> (mTargetPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid target position&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知mRecyclerView要滑动到的目前位置</span></span><br><span class="line">    mRecyclerView.mState.mTargetPosition = mTargetPosition;</span><br><span class="line">    mRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//标志为等待执行</span></span><br><span class="line">    mPendingInitialRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里很重要，会尝试在已有布局中找是否存在目标View，找不到就是null。  我们的案例是一页一页滑动的，所以是肯定找不到下一个页的View</span></span><br><span class="line">    mTargetView = findViewByPosition(getTargetPosition());</span><br><span class="line">    <span class="comment">//onStart空实现</span></span><br><span class="line">    onStart();</span><br><span class="line">    <span class="comment">//最重要的是这里，调用mViewFlinger的postOnAnimation实现滑动</span></span><br><span class="line">    <span class="comment">//ViewFlinger就是个Runnable,下面会分析</span></span><br><span class="line">    mRecyclerView.mViewFlinger.postOnAnimation();</span><br><span class="line"></span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：调用RecyclerView的smoothScrollToPosition 会一路跑到SmoothScroller的start方法，启用ViewFlinger。</p>
<p>这里面最重要的逻辑是  </p>
<ul>
<li>​     赋值SmoothScroller的mTargetPosition，mPendingInitialRun设为true，标志为等待执行，并尝试给mTargetView赋值</li>
<li>​     调用ViewFlinger的postOnAnimation 开始动画</li>
</ul>
<h2 id="2-简单分析ViewFlinger"><a href="#2-简单分析ViewFlinger" class="headerlink" title="2.简单分析ViewFlinger"></a>2.简单分析ViewFlinger</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RecyclerView的内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewFlinger</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一段代码   尝试滑动消费，一旦smoothScroller.onAnimation被调用，isPendingInitialRun设置成false</span></span><br><span class="line">        <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            smoothScroller.onAnimation(consumedX, consumedY);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二段代码   如果isPendingInitialRun还是true，即第一段代码没有被调用，   传入0，0 ，让smoothScroller至少要被调用1次</span></span><br><span class="line">        <span class="keyword">if</span> (smoothScroller != <span class="literal">null</span> &amp;&amp; smoothScroller.isPendingInitialRun()) &#123;</span><br><span class="line">            smoothScroller.onAnimation(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>ViewFlinger是个Runnable，主要看run方法，可以看出滑动的逻辑主要还是Scroller。</li>
<li>但我们smoothScrollToPosition一路走下来，只是设置了mTargetPosition，并不会对ViewFlinger的mOverScroller做出任何改变，它没有任何滑动数据，所以scroller.computeScrollOffset()会返回false， smoothScroller.onAnimation不会在第一段代码中被调用</li>
<li>走向了第二段代码，又跑回了SmoothScroller的onAnimation方法</li>
</ul>
<h2 id="3-简单分析SmoothScroller"><a href="#3-简单分析SmoothScroller" class="headerlink" title="3.简单分析SmoothScroller"></a>3.简单分析SmoothScroller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onAnimation</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 下面的 if 块存在可以让 LayoutManager 在正确的位置滚动 1 个像素方向，以便使 LayoutManager 绘制两页的视图，</span></span><br><span class="line">    <span class="comment">//因此 在进一步滚动之前可以找到目标视图。这样做是为了防止初始滚动距离滚动超过视图，</span></span><br><span class="line">    <span class="comment">//这会导致看起来很紧张的动画。</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingInitialRun &amp;&amp; mTargetView == <span class="literal">null</span> &amp;&amp; mLayoutManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">PointF</span> <span class="variable">pointF</span> <span class="operator">=</span> computeScrollVectorForPosition(mTargetPosition);</span><br><span class="line">        <span class="keyword">if</span> (pointF != <span class="literal">null</span> &amp;&amp; (pointF.x != <span class="number">0</span> || pointF.y != <span class="number">0</span>)) &#123;</span><br><span class="line">            recyclerView.scrollStep(</span><br><span class="line">                (<span class="type">int</span>) Math.signum(pointF.x),</span><br><span class="line">                (<span class="type">int</span>) Math.signum(pointF.y),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPendingInitialRun = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  google的注释解答了一切</p>
<p>  如果这个SmoothScroller 【从来没有运行过】 &amp;&amp;【还找不到目前View】，将会调用recyclerView.scrollStep向正确方向滑动1px。</p>
<p><strong><font color="#FF0000">这个就是layoutState.mAvailable的1px由来</font></strong></p>
<h2 id="4-分析从scrollStep到最重要的fill方法调用链"><a href="#4-分析从scrollStep到最重要的fill方法调用链" class="headerlink" title="4.分析从scrollStep到最重要的fill方法调用链"></a>4.分析从scrollStep到最重要的fill方法调用链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--recyclerView.scrollStep(1px)</span><br><span class="line">--layoutManager.scrollHorizontallyBy(1px)</span><br><span class="line">--layoutManager.scrollBy(1px)</span><br><span class="line">     --updateLayoutState(1px)</span><br><span class="line">        -- calculateExtraLayoutSpace()</span><br><span class="line">           --getExtraLayoutSpace()  </span><br><span class="line"> --layoutManager.fill(RecyclerView.Recycler recycler, LayoutState layoutState,State state, boolean stopOnFocusable)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateLayoutState</span><span class="params">(<span class="type">int</span> layoutDirection, <span class="type">int</span> requiredSpace,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> canUseExistingSpace, RecyclerView.State state)</span> &#123;</span><br><span class="line">    <span class="comment">//mAvailable设置为1px</span></span><br><span class="line">    mLayoutState.mAvailable = requiredSpace;</span><br><span class="line">    <span class="comment">//计算额外需要空间</span></span><br><span class="line">    calculateExtraLayoutSpace(state, mReusableIntPair);</span><br><span class="line">    <span class="comment">//mExtraFillSpace设置为264px</span></span><br><span class="line">    mLayoutState.mExtraFillSpace = mReusableIntPair[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">calculateExtraLayoutSpace</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView.State state,</span></span><br><span class="line"><span class="params">                                         <span class="meta">@NonNull</span> <span class="type">int</span>[] extraLayoutSpace)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">extraLayoutSpaceStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">extraLayoutSpaceEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算额外需要空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">extraScrollSpace</span> <span class="operator">=</span> getExtraLayoutSpace(state);</span><br><span class="line">    <span class="keyword">if</span> (mLayoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">        extraLayoutSpaceStart = extraScrollSpace;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extraLayoutSpaceEnd = extraScrollSpace;</span><br><span class="line">    &#125;</span><br><span class="line">    extraLayoutSpace[<span class="number">0</span>] = extraLayoutSpaceStart;</span><br><span class="line">    extraLayoutSpace[<span class="number">1</span>] = extraLayoutSpaceEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getExtraLayoutSpace</span><span class="params">(RecyclerView.State state)</span> &#123;   <span class="comment">// 这个也是ViewPager2实现多页加载的核心函数</span></span><br><span class="line">    <span class="comment">//如果有目标位置，返回RecyclerView的宽度/高度，否则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (state.hasTargetScrollPosition()) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOrientationHelper.getTotalSpace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    到此为之 ，remainingSpace的265【layoutState.mAvailable的1px和layoutState.mExtraFillSpace的264px组成】是如何生成知道了。</p>
<ol>
<li>步骤1 .smoothScrollToPosition调用，设置了targetPosition，但因为只有一页View，是找不到mTargetView。调用ViewFlinger滑动，</li>
<li>步骤2.但ViewFlinger没有滑动数据，调用SmoothScroller的onAnimation(0,0)方法</li>
<li>步骤3.SmoothScroller如果还没有运行过，且找不到mTargetView，会向滑动方向滑动1px。mLayoutState.mAvailable&#x3D;1px</li>
<li>步骤4.因为targetPosition不是空，会增加一页额外空间。  mLayoutState.mExtraFillSpace &#x3D; 一页空间;</li>
<li>步骤5. fill View时，1px+一页空间 会导致加入两个页面</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从第三步分析解决，只有找不到mTargetView时，才会走下面步骤的逻辑。那我们只要提前让mTargetView不为null就行了。</p>
<p>我们学习一下源码的思路，在调用smoothScrollToPosition滑向下一页前，手动滑动1px，让目标View提前出现在屏幕上，这样子smoothScrollToPosition调用时就mTargetView就能被找到，不是null了</p>
<p>滑向下一页的正确代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView?.scrollBy(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">recyclerView?.smoothScrollToPosition(position + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<p>解决方案很简单，就一行代码，但知道怎么解决却花了几天时间研究RecyclerView源码   。。。。。。。。。。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide知识点</title>
    <url>/post/692dc279.html</url>
    <content><![CDATA[<h1 id="Glide-OKHTTP3"><a href="#Glide-OKHTTP3" class="headerlink" title="Glide+OKHTTP3"></a>Glide+OKHTTP3</h1><h2 id="1-Glide-接入OKHttp3"><a href="#1-Glide-接入OKHttp3" class="headerlink" title="1.Glide 接入OKHttp3"></a>1.Glide 接入OKHttp3</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api(<span class="string">&quot;com.github.bumptech.glide:glide:$&#123;glide_version&#125;&quot;</span>) &#123;</span><br><span class="line">    exclude(<span class="attr">group:</span> <span class="string">&#x27;androidx.annotation&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;annotation&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">implementation(<span class="string">&quot;com.github.bumptech.glide:okhttp3-integration:$&#123;glide_version&#125;&quot;</span>)&#123;</span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&quot;com.squareup.okhttp3&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;okhttp&quot;</span></span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&quot;com.android.support&quot;</span></span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&quot;com.squareup.okio&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;okio&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api <span class="string">&quot;com.squareup.okhttp3:okhttp:$&#123;okhttp_version&#125;&quot;</span></span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h2 id="2-okhttp3-integration核心代码"><a href="#2-okhttp3-integration核心代码" class="headerlink" title="2.okhttp3-integration核心代码"></a>2.okhttp3-integration核心代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public final class OkHttpLibraryGlideModule extends LibraryGlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(</span><br><span class="line">      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) &#123;</span><br><span class="line">    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-替换自定义的OKHttpClient"><a href="#3-替换自定义的OKHttpClient" class="headerlink" title="3.替换自定义的OKHttpClient"></a>3.替换自定义的OKHttpClient</h2><p>第二步可以看出，arr中使用的是LibraryGlideModule，项目中使用自定义的AppGlideModule，就可以比LibraryGlideModule更晚执行，从而替代自定义的OKHttpClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyGlideModule</span> <span class="keyword">extends</span> <span class="title class_">AppGlideModule</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerComponents</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Glide glide, <span class="meta">@NonNull</span> Registry registry)</span> &#123;</span><br><span class="line">        OkHttpClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder();</span><br><span class="line">        Call.<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build();</span><br><span class="line">        registry.replace(GlideUrl.class,InputStream.class, <span class="keyword">new</span> <span class="title class_">OkHttpUrlLoader</span>.Factory(factory));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-GlideModule的registerComponents方法是什么时候被调用的？"><a href="#4-GlideModule的registerComponents方法是什么时候被调用的？" class="headerlink" title="4.GlideModule的registerComponents方法是什么时候被调用的？"></a>4.GlideModule的registerComponents方法是什么时候被调用的？</h2><p><img src="https://s3.bmp.ovh/imgs/2023/07/31/c035ed8ed3cd009e.jpg"></p>
<p>可以看出是图片下载被解析时，调用getRegistry方法时，如果还未初始化，就会走初始化逻辑，调用registerComponents</p>
<h1 id="Glide-OKHttp3-线程池分析"><a href="#Glide-OKHttp3-线程池分析" class="headerlink" title="Glide+OKHttp3 线程池分析"></a>Glide+OKHttp3 线程池分析</h1><h2 id="1-Glide线程池"><a href="#1-Glide线程池" class="headerlink" title="1.Glide线程池"></a>1.Glide线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.GlideBuilder</span></span><br><span class="line">Glide <span class="title function_">build</span><span class="params">(<span class="meta">@NonNull</span> Context context,List&lt;GlideModule&gt; manifestModules, AppGlideModule annotationGeneratedGlideModule)</span> &#123;</span><br><span class="line">    <span class="comment">//图片下载线程池</span></span><br><span class="line">    <span class="keyword">if</span> (sourceExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//硬盘解析线程池</span></span><br><span class="line">    <span class="keyword">if</span> (diskCacheExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//动画解析线程池</span></span><br><span class="line">    <span class="keyword">if</span> (animationExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        animationExecutor = GlideExecutor.newAnimationExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://s3.bmp.ovh/imgs/2023/08/16/f29dedbeb0a190b2.jpg"></p>
<p> 图片下载线程池是个【核心4线程，最多4线程】的线程池</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/08/16/c4fcc46afe34fc6e.jpg"></p>
<p>  硬盘解析线程池是个【核心1线程，最多1线程】的线程池</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/08/16/9d4c9903a1a4901e.jpg"></p>
<p>动画解析线程池是个【核心2线程，最多2线程】的线程池</p>
<ol>
<li><em><strong>在未接入OKHttp3时，Source线程池用于下载图片，可以看出最多支持4个图片同时下载</strong></em></li>
<li><em><strong>在接入OKHttp3时，Source线程池用于向OKHttp3线程池提交下载任务获得InputStream 基本是瞬间完成提交任务，等Okhttp3下载回调，所以下载图片取决于OKHttp3配置</strong></em></li>
</ol>
<h2 id="2-OkHttp3线程池"><a href="#2-OkHttp3线程池" class="headerlink" title="2.OkHttp3线程池"></a>2.OkHttp3线程池</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">        executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                                                   SynchronousQueue(), threadFactory(<span class="string">&quot;<span class="variable">$okHttpName</span> Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//okhttp3.Dispatcher</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// 最多支持64个请求</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// 每个Host最多支持5个请求</span></span><br><span class="line"></span><br><span class="line">            i.remove()</span><br><span class="line">            asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">            executableCalls.add(asyncCall)</span><br><span class="line">            runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> OKhttp3线程池是无限制的，但最多同时支持64个请求，每个Host同时最多支持5个请求</p>
<h1 id="Glide-into-后图片加载时间"><a href="#Glide-into-后图片加载时间" class="headerlink" title="Glide into()后图片加载时间"></a>Glide into()后图片加载时间</h1><h2 id="需要有具体的宽高，-glide才会加载图片"><a href="#需要有具体的宽高，-glide才会加载图片" class="headerlink" title="需要有具体的宽高， glide才会加载图片"></a><em><strong>需要有具体的宽高， glide才会加载图片</strong></em></h2><p>如果设置了RequestOptions的override方法，则直接调用onSizeReady，否则设置target的回调监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.request.SingleRequest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        target.getSize(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    loadStatus =engine.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ViewTarget啥时候会返回合适的宽高？"><a href="#ViewTarget啥时候会返回合适的宽高？" class="headerlink" title="ViewTarget啥时候会返回合适的宽高？"></a>ViewTarget啥时候会返回合适的宽高？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentWidth</span> <span class="operator">=</span> getTargetWidth();</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentHeight</span> <span class="operator">=</span> getTargetHeight();</span><br><span class="line">    <span class="comment">//判断目前是否有合适的宽高，是则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isViewStateAndSizeValid(currentWidth, currentHeight)) &#123;</span><br><span class="line">        cb.onSizeReady(currentWidth, currentHeight);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cbs.contains(cb)) &#123;</span><br><span class="line">        cbs.add(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置addOnPreDrawListener，View绘制前回调</span></span><br><span class="line">    <span class="keyword">if</span> (layoutListener == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ViewTreeObserver</span> <span class="variable">observer</span> <span class="operator">=</span> view.getViewTreeObserver();</span><br><span class="line">        layoutListener = <span class="keyword">new</span> <span class="title class_">SizeDeterminerLayoutListener</span>(<span class="built_in">this</span>);</span><br><span class="line">        observer.addOnPreDrawListener(layoutListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getTargetHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">verticalPadding</span> <span class="operator">=</span> view.getPaddingTop() + view.getPaddingBottom();</span><br><span class="line">    <span class="type">LayoutParams</span> <span class="variable">layoutParams</span> <span class="operator">=</span> view.getLayoutParams();</span><br><span class="line">    <span class="type">int</span> <span class="variable">layoutParamSize</span> <span class="operator">=</span> layoutParams != <span class="literal">null</span> ? layoutParams.height : PENDING_SIZE;</span><br><span class="line">    <span class="keyword">return</span> getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getTargetDimen</span><span class="params">(<span class="type">int</span> viewSize, <span class="type">int</span> paramSize, <span class="type">int</span> paddingSize)</span> &#123;</span><br><span class="line">    <span class="comment">//params的宽高是固定值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">adjustedParamSize</span> <span class="operator">=</span> paramSize - paddingSize;</span><br><span class="line">    <span class="keyword">if</span> (adjustedParamSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> adjustedParamSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View正打算layout布局，返回PENDING_SIZE 表示目前的宽高不合适，等待PreDrawListener回调</span></span><br><span class="line">    <span class="keyword">if</span> (waitForLayout &amp;&amp; view.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="keyword">return</span> PENDING_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View存在宽高数据，因为这个宽高数据可能是脏数据，所以放这么后面</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">adjustedViewSize</span> <span class="operator">=</span> viewSize - paddingSize;</span><br><span class="line">    <span class="keyword">if</span> (adjustedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> adjustedViewSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//view目前没有请求layout布局，且宽高是WRAP_CONTENT，返回屏幕宽高的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (!view.isLayoutRequested() &amp;&amp; paramSize == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxDisplayLength(view.getContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回PENDING_SIZE 表示目前的宽高不合适，等待PreDrawListener回调</span></span><br><span class="line">    <span class="keyword">return</span> PENDING_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    <strong>into后宽高数据的获取逻辑</strong>：</p>
<ol>
<li>RequestOptions存在overrideWidth, overrideHeight</li>
<li>params的宽高是固定值</li>
<li>viewTarget的waitForLayout是true，且正打算layout布局，则等待PreDrawListener回调（waitForLayout无设置默认值，boolean默认值是false）</li>
<li>view存在真实的宽高数据</li>
<li>view目前没有请求layout布局，且宽高是WRAP_CONTENT，返回屏幕宽高的最大值</li>
<li>等待PreDrawListener回调</li>
</ol>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView曝光踩坑-1</title>
    <url>/post/22258c7a.html</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6949186887609221133">万字长文 - 史上最全ConstraintLayout</a></p>
<p><a href="https://lanshushui.github.io/post/412d5155.html">RecyclerView曝光踩坑-2</a></p>
<p><a href="https://lanshushui.github.io/post/362a61c3.html">RecyclerView曝光踩坑-3</a></p>
<p>基于RecyclerView 1.2.1 版本分析</p>
<h2 id="1-一次Recyclerview的item曝光需求产生的BUG对ConstraintLayout的分析"><a href="#1-一次Recyclerview的item曝光需求产生的BUG对ConstraintLayout的分析" class="headerlink" title="1.一次Recyclerview的item曝光需求产生的BUG对ConstraintLayout的分析"></a>1.一次Recyclerview的item曝光需求产生的BUG对ConstraintLayout的分析</h2><p>曝光逻辑是在ViewHolder的onViewAttachedToWindow进行上报，</p>
<p>最后却发现Recyclerview第一次刷新数据时 发现不在屏幕上的viewholder也调用了onViewAttachedToWindow方法，导致多余非法上报</p>
<blockquote>
<p><font color="red">测试发现是部分viewholder快速进行了onViewAttachedToWindow，然后onViewDetachedFromWindow的操作</font></p>
</blockquote>
<span id="more"></span>

<p><strong>xml布局</strong></p>
<img src="https://s3.bmp.ovh/imgs/2023/05/12/6dcd17d349803a7b.jpg" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyRecyclerView @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = null,</span><br><span class="line">    defStyle: Int = 0</span><br><span class="line">) : RecyclerView(context, attrs, defStyle) &#123;</span><br><span class="line"></span><br><span class="line">    override fun onMeasure(widthSpec: Int, heightSpec: Int) &#123;</span><br><span class="line">        super.onMeasure(widthSpec, heightSpec)</span><br><span class="line">        Log.i(&quot;MyRecyclerView&quot;, &quot;$&#123;MeasureSpec.getMode(heightSpec)&#125; ,$&#123;MeasureSpec.getSize(heightSpec)&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MeasureSpec.EXACTLY   1073741824</span><br><span class="line">MeasureSpec.AT_MOST   -2147483648</span><br><span class="line">MeasureSpec.UNSPECIFIED  0</span><br></pre></td></tr></table></figure>



<p>上面的布局看起来很正常，大多数场景下都可能用到这样子的布局，但就是这样子的布局导致的Log日志是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">21.830</span>  <span class="number">3206</span>-<span class="number">3206</span>  MyRecyclerView          com.example.testcode                 I  -<span class="number">2147483648</span> ,<span class="number">2151</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">21.832</span>  <span class="number">3206</span>-<span class="number">3206</span>  MyRecyclerView          com.example.testcode                 I  <span class="number">1073741824</span> ,<span class="number">776</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">21.847</span>  <span class="number">3206</span>-<span class="number">3206</span>  MyRecyclerView          com.example.testcode                 I  -<span class="number">2147483648</span> ,<span class="number">2151</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">21.849</span>  <span class="number">3206</span>-<span class="number">3206</span>  MyRecyclerView          com.example.testcode                 I  <span class="number">1073741824</span> ,<span class="number">776</span></span><br></pre></td></tr></table></figure>



<p>进入Activity，页面会被绘制两次，ConstraintLayout也会绘制两次，所以形成了四次输出，我们只需要看第一和第二次输出</p>
<p><a href="https://blog.csdn.net/qq_26287435/article/details/123274342">进入Activity时，为何页面布局内View#onMeasure会被调用两次</a></p>
<p>第一输出的是MyRecyclerView父布局的高度，这个是因为ConstraintLayout的子view相互影响布局，第一次无法确定高度导致的</p>
<p>第二次输出才是MyRecyclerView自身的高度</p>
<p>RecyclerView的onMeasure方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mLayout == <span class="literal">null</span>) &#123; <span class="comment">//没有layoutmanager</span></span><br><span class="line">        <span class="keyword">this</span>.defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.mLayout.isAutoMeasureEnabled()) &#123;  <span class="comment">//自动测量，系统的layoutmanager都是开启的，所以一般不进入该分支</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mHasFixedSize) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mLayout.onMeasure(<span class="keyword">this</span>.mRecycler, <span class="keyword">this</span>.mState, widthSpec, heightSpec);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">                <span class="keyword">this</span>.startInterceptRequestLayout();</span><br><span class="line">                <span class="keyword">this</span>.onEnterLayoutOrScroll();</span><br><span class="line">                <span class="keyword">this</span>.processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">                <span class="keyword">this</span>.onExitLayoutOrScroll();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mState.mInPreLayout = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">                    <span class="keyword">this</span>.mState.mInPreLayout = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mAdapterUpdateDuringMeasure = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.stopInterceptRequestLayout(<span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setMeasuredDimension(<span class="keyword">this</span>.getMeasuredWidth(), <span class="keyword">this</span>.getMeasuredHeight());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mAdapter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mState.mItemCount = <span class="keyword">this</span>.mAdapter.getItemCount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.startInterceptRequestLayout();</span><br><span class="line">            <span class="keyword">this</span>.mLayout.onMeasure(<span class="keyword">this</span>.mRecycler, <span class="keyword">this</span>.mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">this</span>.stopInterceptRequestLayout(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.mState.mInPreLayout = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//经常都是走这个分支</span></span><br><span class="line">            int widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">            int heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">            <span class="keyword">this</span>.mLayout.onMeasure(<span class="keyword">this</span>.mRecycler, <span class="keyword">this</span>.mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">this</span>.mLastAutoMeasureSkippedDueToExact = widthMode == <span class="number">1073741824</span> &amp;&amp; heightMode == <span class="number">1073741824</span>;</span><br><span class="line">            <span class="comment">//当宽高都是EXACTLY时，直接return</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mLastAutoMeasureSkippedDueToExact || <span class="keyword">this</span>.mAdapter == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//走到这里说明Recyclerivew是不确定宽高，这时候onMeasure方法会调用dispatchLayoutStep2，导致addView</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mState.mLayoutStep == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.dispatchLayoutStep1();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">this</span>.mState.mIsMeasuring = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.dispatchLayoutStep2();</span><br><span class="line">            <span class="keyword">this</span>.mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mLayout.setMeasureSpecs(MeasureSpec.makeMeasureSpec(<span class="keyword">this</span>.getMeasuredWidth(), <span class="number">1073741824</span>), MeasureSpec.makeMeasureSpec(<span class="keyword">this</span>.getMeasuredHeight(), <span class="number">1073741824</span>));</span><br><span class="line">                <span class="keyword">this</span>.mState.mIsMeasuring = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.dispatchLayoutStep2();</span><br><span class="line">                <span class="keyword">this</span>.mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mLastAutoMeasureNonExactMeasuredWidth = <span class="keyword">this</span>.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">this</span>.mLastAutoMeasureNonExactMeasuredHeight = <span class="keyword">this</span>.getMeasuredHeight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>当RecyclerView宽高不确定时，viewholder的onViewAttachedToWindow是在addView时被调用，addView是在Recyclerview的onMeasuer时被调用</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/12/63478300924c3186.jpg"></p>
<p><strong>所以正是因为第一次传入的错误高度以及Recyclerivew不确定的宽高条件下，导致RecyclerView 在measure阶段add了多余的View，又在layout阶段拿到正确高度的影响下，detach掉 导致的问题</strong></p>
<h2 id="解决方案（让RecyclerView的measure阶段不进行addView操作）"><a href="#解决方案（让RecyclerView的measure阶段不进行addView操作）" class="headerlink" title="解决方案（让RecyclerView的measure阶段不进行addView操作）"></a>解决方案（让RecyclerView的measure阶段不进行addView操作）</h2><p>RecyclerView的measure阶段不进行addView操作  -》》measure阶段能拿到EXACTLY的宽高</p>
<p>1.不用ConstraintLayout，使用LinearLayout，让RecyclerView从始至终都拿到正确的布局高度</p>
<p>2.破坏链式约束</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/12/38f2bd35454f0c3a.jpg"></p>
<p>ConstraintLayout内部不要形成链式的约束，这样子ConstraintLayout第一次就能知道RecyclerView需要的高度是多少</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>ConstraintLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>SnapHelper知识点</title>
    <url>/post/f6744f64.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速滑动时触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSnapPosition</span><span class="params">(RecyclerView.LayoutManager layoutManager, <span class="type">int</span> velocityX,<span class="type">int</span> velocityY)</span></span><br><span class="line"><span class="comment">//缓慢滑动时触发  </span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">findSnapView</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span>    </span><br></pre></td></tr></table></figure>



<span id="more"></span>



<p><em>默认的PagerSnapHelper 是通过内部的findCenterView方法找到距离RecyclerView中点最近的View</em></p>
<p>但如果有需求需要一页一页滑动，但滑动到三分之一处就切换页面，那默认的PagerSnapHelper无法处理，它是滑动到二分之一才进行页面切换。这就需要我们自定义PagerSnapHelper </p>
<h2 id="1-自定义三分之一滑动的PagerSnapHelper"><a href="#1-自定义三分之一滑动的PagerSnapHelper" class="headerlink" title="1.自定义三分之一滑动的PagerSnapHelper"></a>1.自定义三分之一滑动的PagerSnapHelper</h2><p>大部分都是复制默认的PagerSnapHelper ，只需要改动findCenterView方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2018 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lanshushui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.PointF;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearSmoothScroller;</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.OrientationHelper;</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.SnapHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tv.athena.util.common.ScreenUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of the &#123;<span class="doctag">@link</span> SnapHelper&#125; supporting pager style snapping in either vertical or</span></span><br><span class="line"><span class="comment"> * horizontal orientation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * PagerSnapHelper can help achieve a similar behavior to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> androidx.viewpager.widget.ViewPager&#125;. Set both &#123;<span class="doctag">@link</span> RecyclerView&#125; and the items of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RecyclerView.Adapter&#125; to have</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.view.ViewGroup.LayoutParams#MATCH_PARENT&#125; height and width and then attach</span></span><br><span class="line"><span class="comment"> * PagerSnapHelper to the &#123;<span class="doctag">@link</span> RecyclerView&#125; using &#123;<span class="doctag">@link</span> #attachToRecyclerView(RecyclerView)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PagerSnapHelper</span> <span class="keyword">extends</span> <span class="title class_">SnapHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCROLL_ON_FLING_DURATION</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Orientation helpers are lazily created per LayoutManager.</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> OrientationHelper mVerticalHelper;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> OrientationHelper mHorizontalHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachToRecyclerView</span><span class="params">(<span class="meta">@Nullable</span> RecyclerView recyclerView)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">        <span class="built_in">super</span>.attachToRecyclerView(recyclerView);</span><br><span class="line">        mRecyclerView = recyclerView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] calculateDistanceToFinalSnap(<span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager,</span><br><span class="line">                                              <span class="meta">@NonNull</span> View targetView) &#123;</span><br><span class="line">        <span class="type">int</span>[] out = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">            out[<span class="number">0</span>] = distanceToCenter(targetView,</span><br><span class="line">                    getHorizontalHelper(layoutManager));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">            out[<span class="number">1</span>] = distanceToCenter(targetView,</span><br><span class="line">                    getVerticalHelper(layoutManager));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">findSnapView</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">            <span class="keyword">return</span> findCenterView(layoutManager, getVerticalHelper(layoutManager));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">            <span class="keyword">return</span> findCenterView(layoutManager, getHorizontalHelper(layoutManager));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSnapPosition</span><span class="params">(RecyclerView.LayoutManager layoutManager, <span class="type">int</span> velocityX,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> velocityY)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">itemCount</span> <span class="operator">=</span> layoutManager.getItemCount();</span><br><span class="line">        <span class="keyword">if</span> (itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RecyclerView.NO_POSITION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">OrientationHelper</span> <span class="variable">orientationHelper</span> <span class="operator">=</span> getOrientationHelper(layoutManager);</span><br><span class="line">        <span class="keyword">if</span> (orientationHelper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RecyclerView.NO_POSITION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A child that is exactly in the center is eligible for both before and after</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">closestChildBeforeCenter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">distanceBefore</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">View</span> <span class="variable">closestChildAfterCenter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">distanceAfter</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the first view before the center, and the first view after the center</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> layoutManager.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> layoutManager.getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> distanceToCenter(child, orientationHelper);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">0</span> &amp;&amp; distance &gt; distanceBefore) &#123;</span><br><span class="line">                <span class="comment">// Child is before the center and closer then the previous best</span></span><br><span class="line">                distanceBefore = distance;</span><br><span class="line">                closestChildBeforeCenter = child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (distance &gt;= <span class="number">0</span> &amp;&amp; distance &lt; distanceAfter) &#123;</span><br><span class="line">                <span class="comment">// Child is after the center and closer then the previous best</span></span><br><span class="line">                distanceAfter = distance;</span><br><span class="line">                closestChildAfterCenter = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the position of the first child from the center, in the direction of the fling</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">forwardDirection</span> <span class="operator">=</span> isForwardFling(layoutManager, velocityX, velocityY);</span><br><span class="line">        <span class="keyword">if</span> (forwardDirection &amp;&amp; closestChildAfterCenter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> layoutManager.getPosition(closestChildAfterCenter);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!forwardDirection &amp;&amp; closestChildBeforeCenter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> layoutManager.getPosition(closestChildBeforeCenter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There is no child in the direction of the fling. Either it doesn&#x27;t exist (start/end of</span></span><br><span class="line">        <span class="comment">// the list), or it is not yet attached (very rare case when children are larger then the</span></span><br><span class="line">        <span class="comment">// viewport). Extrapolate from the child that is visible to get the position of the view to</span></span><br><span class="line">        <span class="comment">// snap to.</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">visibleView</span> <span class="operator">=</span> forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter;</span><br><span class="line">        <span class="keyword">if</span> (visibleView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RecyclerView.NO_POSITION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">visiblePosition</span> <span class="operator">=</span> layoutManager.getPosition(visibleView);</span><br><span class="line">        <span class="type">int</span> <span class="variable">snapToPosition</span> <span class="operator">=</span> visiblePosition</span><br><span class="line">                + (isReverseLayout(layoutManager) == forwardDirection ? -<span class="number">1</span> : +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snapToPosition &lt; <span class="number">0</span> || snapToPosition &gt;= itemCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> RecyclerView.NO_POSITION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapToPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isForwardFling</span><span class="params">(RecyclerView.LayoutManager layoutManager, <span class="type">int</span> velocityX,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> velocityY)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">            <span class="keyword">return</span> velocityX &gt; <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> velocityY &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isReverseLayout</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">itemCount</span> <span class="operator">=</span> layoutManager.getItemCount();</span><br><span class="line">        <span class="keyword">if</span> ((layoutManager <span class="keyword">instanceof</span> RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123;</span><br><span class="line">            RecyclerView.SmoothScroller.<span class="type">ScrollVectorProvider</span> <span class="variable">vectorProvider</span> <span class="operator">=</span></span><br><span class="line">                    (RecyclerView.SmoothScroller.ScrollVectorProvider) layoutManager;</span><br><span class="line">            <span class="type">PointF</span> <span class="variable">vectorForEnd</span> <span class="operator">=</span> vectorProvider.computeScrollVectorForPosition(itemCount - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (vectorForEnd != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> vectorForEnd.x &lt; <span class="number">0</span> || vectorForEnd.y &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> RecyclerView.SmoothScroller <span class="title function_">createScroller</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(layoutManager <span class="keyword">instanceof</span> RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinearSmoothScroller</span>(PagerSnapHelper.<span class="built_in">this</span>.mRecyclerView.getContext()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">MILLISECONDS_PER_INCH</span> <span class="operator">=</span> <span class="number">25f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onTargetFound</span><span class="params">(View targetView, RecyclerView.State state, Action action)</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] snapDistances = calculateDistanceToFinalSnap(mRecyclerView.getLayoutManager(),</span><br><span class="line">                        targetView);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> snapDistances[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dy</span> <span class="operator">=</span> snapDistances[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> calculateTimeForDeceleration(Math.max(Math.abs(dx), Math.abs(dy)));</span><br><span class="line">                <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    action.update(dx, dy, time, mDecelerateInterpolator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">float</span> <span class="title function_">calculateSpeedPerPixel</span><span class="params">(DisplayMetrics displayMetrics)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> MILLISECONDS_PER_INCH / displayMetrics.densityDpi;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">calculateTimeForScrolling</span><span class="params">(<span class="type">int</span> dx)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(MAX_SCROLL_ON_FLING_DURATION, <span class="built_in">super</span>.calculateTimeForScrolling(dx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">distanceToCenter</span><span class="params">(<span class="meta">@NonNull</span> View targetView, OrientationHelper helper)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCenter</span> <span class="operator">=</span> helper.getDecoratedStart(targetView)</span><br><span class="line">                + (helper.getDecoratedMeasurement(targetView) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">containerCenter</span> <span class="operator">=</span> helper.getStartAfterPadding() + helper.getTotalSpace() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> childCenter - containerCenter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到将要展示的View</span></span><br><span class="line"><span class="comment">     * 若无新View展示超过三分之一，则返回当前View</span></span><br><span class="line"><span class="comment">     * 否则返回新加入的View</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> View <span class="title function_">findCenterView</span><span class="params">(RecyclerView.LayoutManager layoutManager,</span></span><br><span class="line"><span class="params">                                OrientationHelper helper)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> layoutManager.getChildCount();</span><br><span class="line">        <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">View</span> <span class="variable">CurContainer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> layoutManager.getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//child view是否是当前正在显示的View</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isCurContainer</span> <span class="operator">=</span> isCurPage((ViewGroup) child);</span><br><span class="line">            <span class="keyword">if</span> (isCurContainer) &#123;</span><br><span class="line">                CurContainer = child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> ScreenUtils.getScreenHeight();</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxScrollY</span> <span class="operator">=</span> maxHeight / <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span>[] out = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">            child.getLocationInWindow(out);</span><br><span class="line">            <span class="keyword">if</span> (isCurContainer) &#123; <span class="comment">//当前View是当前页</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(out[<span class="number">1</span>]) &lt;= maxScrollY) &#123; <span class="comment">//滑动幅度小于三分之一</span></span><br><span class="line">                    <span class="keyword">return</span> child;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//存在新View滑动超过三分之一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//当前View不是当前页</span></span><br><span class="line">                <span class="keyword">if</span> (maxHeight - Math.abs(out[<span class="number">1</span>]) &gt;= maxScrollY) &#123; <span class="comment">//露出的部分超过三分之一</span></span><br><span class="line">                    <span class="keyword">return</span> child;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CurContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> OrientationHelper <span class="title function_">getOrientationHelper</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getVerticalHelper(layoutManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getHorizontalHelper(layoutManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> OrientationHelper <span class="title function_">getVerticalHelper</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVerticalHelper == <span class="literal">null</span> || mVerticalHelper.getLayoutManager() != layoutManager) &#123;</span><br><span class="line">            mVerticalHelper = OrientationHelper.createVerticalHelper(layoutManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mVerticalHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> OrientationHelper <span class="title function_">getHorizontalHelper</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> RecyclerView.LayoutManager layoutManager)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHorizontalHelper == <span class="literal">null</span> || mHorizontalHelper.getLayoutManager() != layoutManager) &#123;</span><br><span class="line">            mHorizontalHelper = OrientationHelper.createHorizontalHelper(layoutManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHorizontalHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>SnapHelper</tag>
      </tags>
  </entry>
  <entry>
    <title>Systrace使用技巧</title>
    <url>/post/1c5b60a8.html</url>
    <content><![CDATA[<p><em>建议Pyenv 进行Python的版本管理</em></p>
<p><a href="https://www.bilibili.com/video/BV1KJ411Q7qu/?spm_id_from=333.999.0.0&vd_source=f02f9d2b6ca3710611c51219432586fa">Perfetto使用技巧</a></p>
<p>adb命令： adb pull &#x2F;data&#x2F;local&#x2F;traces</p>
<span id="more"></span>



<h2 id="1-Systrace的使用-关于Android-Systrace的使用"><a href="#1-Systrace的使用-关于Android-Systrace的使用" class="headerlink" title="1. Systrace的使用    关于Android Systrace的使用"></a>1. Systrace的使用    <a href="https://blog.csdn.net/qq_40494059/article/details/124826281">关于Android Systrace的使用</a></h2><p><img src="/images/Systrace.png" alt="systrace"></p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>使用技巧</category>
      </categories>
      <tags>
        <tag>Systrace</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewModel知识点</title>
    <url>/post/4500f14b.html</url>
    <content><![CDATA[<p>ViewModel出现了调用onCleared方法 又马上被创建的情况</p>
<h2 id="1-ViewModel的onCleared方法被调用时机"><a href="#1-ViewModel的onCleared方法被调用时机" class="headerlink" title="1.ViewModel的onCleared方法被调用时机"></a>1.ViewModel的onCleared方法被调用时机</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FragmentStateManager</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//清除ViewModel</span></span><br><span class="line">    <span class="keyword">if</span> ((beingRemoved &amp;&amp; !mFragment.mBeingSaved) || shouldClear) &#123;</span><br><span class="line">        mFragmentStore.getNonConfig().clearNonConfigState(mFragment);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragment.performDestroy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Fragment   </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    mChildFragmentManager.dispatchDestroy();</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    mState = ATTACHED;</span><br><span class="line">    mCalled = <span class="literal">false</span>;</span><br><span class="line">    mIsCreated = <span class="literal">false</span>;</span><br><span class="line">    onDestroy();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SuperNotCalledException</span>(<span class="string">&quot;Fragment &quot;</span> + <span class="built_in">this</span></span><br><span class="line">                                          + <span class="string">&quot; did not call through to super.onDestroy()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到调用顺序：</p>
<blockquote>
<p>1.先清除Fragment自身的ViewModel</p>
<p>2.调用Fragment的performDestroy</p>
<p>​    2.1. 调用mChildFragmentManager的dispatchDestroy，递归走上面的逻辑</p>
<p>​    2.2 生命周期LifecycleRegistry的回调</p>
<p>​    2.3 调用Frament自身的onDestroy方法</p>
</blockquote>
<p><em>可以看出【ViewModel的onClear方法】调用是快于【Fragment的onDestroy方法】，所以不可以在Fragment的onDestroy中调用viewmodel变量，此时获得的viewmodel实例是新创建的，并不是之前持有的viewmodel变量。</em></p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ViewModel</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager2知识点</title>
    <url>/post/5f633874.html</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>ViewPager2的实现原理是RecyclerView</p>
<span id="more"></span>



<p>offscreenPageLimit参数的原理是增加RecyclerView的绘制区域   <strong>ViewPager2内部LinearLayoutManagerImpl类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LinearLayoutManagerImpl</span> <span class="keyword">extends</span> <span class="title class_">LinearLayoutManager</span> &#123;</span><br><span class="line">    LinearLayoutManagerImpl(Context context) &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">calculateExtraLayoutSpace</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView.State state, <span class="meta">@NonNull</span> <span class="type">int</span>[] extraLayoutSpace)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageLimit</span> <span class="operator">=</span> ViewPager2.<span class="built_in">this</span>.getOffscreenPageLimit();</span><br><span class="line">        <span class="keyword">if</span> (pageLimit == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.calculateExtraLayoutSpace(state, extraLayoutSpace);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">offscreenSpace</span> <span class="operator">=</span> ViewPager2.<span class="built_in">this</span>.getPageSize() * pageLimit;</span><br><span class="line">            extraLayoutSpace[<span class="number">0</span>] = offscreenSpace;</span><br><span class="line">            extraLayoutSpace[<span class="number">1</span>] = offscreenSpace;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ViewPager2</tag>
      </tags>
  </entry>
  <entry>
    <title>协程Cancel知识点</title>
    <url>/post/a442dbbf.html</url>
    <content><![CDATA[<p>参考文档：<a href="https://juejin.cn/post/7158008928930906148#heading-0">Kotlin 协程的取消机制超详细解读</a></p>
<span id="more"></span>



<p><em>协程被cancel后，只有在【运行前】或者【跑到挂起点】才会退出</em></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job= CoroutineScope(Dispatchers.Default + SupervisorJob()).launch &#123;</span><br><span class="line">    MLog.info(<span class="string">&quot;协程测试&quot;</span>, <span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">    MLog.info(<span class="string">&quot;协程测试&quot;</span>,<span class="string">&quot;协程是否被cancel <span class="subst">$&#123;!isActive&#125;</span>&quot;</span>)</span><br><span class="line">    MLog.info(<span class="string">&quot;协程测试&quot;</span>,<span class="string">&quot;协程还在跑&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    MLog.info(<span class="string">&quot;协程测试&quot;</span>,<span class="string">&quot;协程跑完了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">viewModelScope.launch &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的日志内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-07-03 10:45:21.397 12710-12776 协程测试                    com.sodo.live                        I  协程是否被cancel true</span><br><span class="line">2023-07-03 10:45:21.398 12710-12776 协程测试                    com.sodo.live                        I  协程还在跑</span><br></pre></td></tr></table></figure>



<p>代码的目的是在协程运行在Thread.sleep(5000)时，cancel掉协程</p>
<p>看日志可以看出，协程虽然被cancel了，但还在跑，直到运行到挂起点，才退出协程</p>
<p>看参考文档可以知道，此时运行到delay代码时，抛出了CancellationException异常，导致协程结束</p>
<p>协程的调度线程和cancel代码执行线程是同一个时，一般不用太关注这一点，因为符合时序，调用cancel时，协程一定处于被调度前或者运行在挂起点。</p>
<p>但不在同一线程时，可能会出现协程运行在某一行时，调用cancel的场景，但协程此时并不会停止执行，会继续运行到挂起点，这可能就会出现问题</p>
<p>例如资源找不到，View找不到</p>
<p>错误代码样例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> job:Job?=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        job= CoroutineScope(Dispatchers.Default + SupervisorJob()).launch &#123;</span><br><span class="line">            <span class="keyword">val</span> subView =view.findViewById(R.id.test)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            subView.gone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        job?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概率不大，但也有可能出现崩溃。findViewById过程中，Activity被Destroy了，找不到View出现崩溃</p>
<p>虽然onDestroy方法中协程被cancel了，但协程还是会继续执行delay之前的代码</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView曝光踩坑-2</title>
    <url>/post/412d5155.html</url>
    <content><![CDATA[<p><a href="https://lanshushui.github.io/post/22258c7a.html">RecyclerView曝光踩坑-1</a></p>
<p><a href="https://lanshushui.github.io/post/362a61c3.html">RecyclerView曝光踩坑-3</a></p>
<p>基于RecyclerView 1.2.1 版本分析</p>
<p><em>问题场景是 发现屏幕内的一个豆腐块调用notifyItemChanged后，会导致屏幕外的viewHolder的onViewAttachedToWindow也会被调用</em></p>
<span id="more"></span>



<h2 id="1-notifyItemChanged导致不在屏幕上的viewHolder曝光"><a href="#1-notifyItemChanged导致不在屏幕上的viewHolder曝光" class="headerlink" title="1.notifyItemChanged导致不在屏幕上的viewHolder曝光"></a>1.notifyItemChanged导致不在屏幕上的viewHolder曝光</h2><p>RecyclerView场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------</span><br><span class="line">| 1     2 |</span><br><span class="line">| 3     4 |</span><br><span class="line">| 5     6 |</span><br><span class="line">| 7     8 |</span><br><span class="line">----------</span><br><span class="line">  9    10</span><br></pre></td></tr></table></figure>



<p>当notifyItemChanged位置1时，<font color="red">位置9和位置10的onViewAttachedToWindow会被调用</font>，导致不断上报错误的曝光数据。</p>
<p>特别是位置1需要持续刷新，调用notifyItemChanged，上报的错误量不断增加。</p>
<p><em>前提：要了解RecyclerView基本的Layout逻辑</em></p>
<p><strong>基础调用链：</strong></p>
<p><strong>RecyclerView                        –                  dispatchLayout()</strong></p>
<p><strong>RecyclerView                        –                  dispatchLayoutStep1()</strong></p>
<p><strong>LinearLayoutManager        –                  onLayoutChildren()</strong></p>
<p><strong>LinearLayoutManager        –                  fill()</strong></p>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager类   fill函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span><br><span class="line"><span class="params">         RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">  	<span class="comment">//可用空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtraFillSpace;</span><br><span class="line">    <span class="comment">//layout完子item后，子item的相关数据的封装类</span></span><br><span class="line">    <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">    <span class="comment">//不断地判断 可用空间，若大于零则不断加入View</span></span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        <span class="comment">//初始化layoutChunkResult</span></span><br><span class="line">        layoutChunkResult.resetInternal();</span><br><span class="line">        <span class="comment">//正在布局子item,并将layout完，将子item的相关数据封装在layoutChunkResult中</span></span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增加偏移量</span></span><br><span class="line">        layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关键代码，提取layout的消耗空间，将可用空间不断减少</span></span><br><span class="line">        <span class="comment">//是条件进入的，说明有些情况，即使我们addView了，也不会消耗可用空间，RecyclerView会继续while循环addView</span></span><br><span class="line">        <span class="comment">//我们的BUG是因为第一个判断导致的，即mIgnoreConsumed为ture。通常该变量都是false的</span></span><br><span class="line">        <span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != <span class="literal">null</span></span><br><span class="line">            || !state.isPreLayout()) &#123;</span><br><span class="line">            layoutState.mAvailable -= layoutChunkResult.mConsumed;</span><br><span class="line">           	<span class="comment">//可用空间不断减少</span></span><br><span class="line">            remainingSpace -= layoutChunkResult.mConsumed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</span><br><span class="line">            <span class="keyword">if</span> (layoutState.mAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            recycleByLayoutState(recycler, layoutState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>什么情况下mIgnoreConsumed是true呢，继续跟进layoutChunk函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager类   fill函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span><br><span class="line"><span class="params">                 LayoutState layoutState, LayoutChunkResult result)</span> &#123;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> layoutState.next(recycler);</span><br><span class="line">    <span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> (LayoutParams) view.getLayoutParams();</span><br><span class="line">     <span class="comment">// 如果该view是remove状态或者是change状态，将mIgnoreConsumed设置false，不消化可用空间</span></span><br><span class="line">    <span class="keyword">if</span> (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">        result.mIgnoreConsumed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由上面可以看出，当对应的view是change状态时，addView也不会消耗RecyclerView的可用空间，让RecyclerView可以add进更多的View</p>
<h2 id="总结问题原因"><a href="#总结问题原因" class="headerlink" title="总结问题原因"></a>总结问题原因</h2><p>因为我们notifyItemChanged位置1导致布局重新绘制，同时将位置1的view设置成change状态。在绘制过程中，位置位置1，2所在的那一行豆腐块虽然被绘制了，但不消化可用空间的值，对应RecyclerView来说相当于多了一行豆腐块绘制空间，让位置9，10的豆腐块可以被addView和attach。在后续dispatchLayoutStep3中中又会将不在屏幕的view移除掉。造成位置9和10的viewholder不断的attach和detach。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从代码上判断，这个是RecyclerView的正常绘制逻辑，无法避免。</p>
<p>RecyclerView在dispatchLayoutStep1中多add一些view，dispatchLayoutStep3中将不合适的view移出去，达到动画效果。</p>
<p>dispatchLayoutStep1和dispatchLayoutStep3都是在一个消息循环中完成的，所以我们可以通过post操作完成曝光和取消曝光的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> task= Runnable &#123; </span><br><span class="line">    <span class="comment">//曝光逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(holder: <span class="type">BaseViewHolder</span>)</span></span> &#123;</span><br><span class="line">    holder.itemView.post(task)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(holder: <span class="type">BaseViewHolder</span>)</span></span> &#123;</span><br><span class="line">    holder.itemView.removeCallbacks(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>启动优化想法</title>
    <url>/post/6af44e8.html</url>
    <content><![CDATA[<p>一些小想法</p>
<span id="more"></span>



<h2 id="1、所需SDK多线程初始化"><a href="#1、所需SDK多线程初始化" class="headerlink" title="1、所需SDK多线程初始化"></a>1、所需SDK多线程初始化</h2><h2 id="2-首页数据预拉取"><a href="#2-首页数据预拉取" class="headerlink" title="2. 首页数据预拉取"></a>2. 首页数据预拉取</h2><h2 id="3-首页豆腐块View预Inflate"><a href="#3-首页豆腐块View预Inflate" class="headerlink" title="3. 首页豆腐块View预Inflate"></a>3. 首页豆腐块View预Inflate</h2><p>在首页setContentView之前异步inflate View</p>
<p>使用 AsyncLayoutInflater + SimplePool技术</p>
<h2 id="4-预连接图片域名的TCP"><a href="#4-预连接图片域名的TCP" class="headerlink" title="4. 预连接图片域名的TCP"></a>4. 预连接图片域名的TCP</h2><p>Glide接入OKHttp后，域名不支持Http2.0的情况下，默认最多支持5个相同域名的并发TCP连接。图片域名一般是固定的，我们可以在APP启动时使用Glide预加载5个该域名图片。</p>
<p>甚至不需要图片url，把域名直接抛给Glide也行，虽然会解析成图片失败，但我们的目的只是建立TCP连接，所以Http的失败并没有关系。</p>
<p>提前使用Glide加载网络图片，也提前了Glide相关初始化和线程池的创建。</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>想法</category>
      </categories>
      <tags>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>小知识点</title>
    <url>/post/89f567a5.html</url>
    <content><![CDATA[<p>小知识点</p>
<span id="more"></span>



<h2 id="1-Span"><a href="#1-Span" class="headerlink" title="1.Span"></a>1.Span</h2><p><strong>ReplacementSpan</strong></p>
<h2 id="2-substring可能会把两个字符的emoji分开，导致显示无法显示的-字符。"><a href="#2-substring可能会把两个字符的emoji分开，导致显示无法显示的-字符。" class="headerlink" title="2.substring可能会把两个字符的emoji分开，导致显示无法显示的?字符。"></a>2.substring可能会把两个字符的emoji分开，导致显示无法显示的?字符。</h2><p>判断边界字符是否是Unicode代理项代码单元，substring时进行位置偏移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Character.isLowSurrogate()</span><br><span class="line"></span><br><span class="line">Character.isHighSurrogate()</span><br></pre></td></tr></table></figure>



<h2 id="2-onSaveInstanceState-onStop"><a href="#2-onSaveInstanceState-onStop" class="headerlink" title="2.onSaveInstanceState-onStop"></a>2.onSaveInstanceState-onStop</h2><p>下拉状态栏： onSaveInstanceState ，onPause，onStop 都不会调用</p>
<p>按Home： onPause –onStop–onSaveInstanceState 都会被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callActivityOnStop</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> saveState, String reason)</span> &#123;</span><br><span class="line">    <span class="comment">// Before P onSaveInstanceState was called before onStop, P是安卓9.0版本</span></span><br><span class="line">    <span class="comment">//starting with P it&#x27;s called after.    Before Honeycomb state was always saved before onPause.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shouldSaveState</span> <span class="operator">=</span> saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="literal">null</span></span><br><span class="line">        &amp;&amp; !r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isPreP</span> <span class="operator">=</span> r.isPreP();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.performStop(r.mPreserveWindow, reason);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to stop activity &quot;</span></span><br><span class="line">                + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_STOP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安卓9.0版本前onSaveInstanceState在onStop前被调用，安卓9.0版本前onSaveInstanceState在onStop后被调用</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>小知识点</category>
      </categories>
      <tags>
        <tag>使用提醒</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型知识点</title>
    <url>/post/71d175cf.html</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/7022581523048038408">“界限”带来的灵活性 —— Java泛型的上下界</a></p>
<p><a href="https://www.jianshu.com/p/ce9b093f6967">Kotlin 范型之泛型约束、类型投影、星号投影</a></p>
<span id="more"></span>



<h2 id="1-上界-Extend（-out-）-下界：Super-in"><a href="#1-上界-Extend（-out-）-下界：Super-in" class="headerlink" title="1.上界: Extend（ out ）  下界：Super( in )"></a>1.上界: Extend（ out ）  下界：Super( in )</h2><blockquote>
<p>extend（ out ） ——————  只能取，不能存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Apple&gt; appleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    appleList.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    appleList.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">	<span class="comment">//如果能存Fruit的子类 ，万一你存的是banana ，appleList.get()方法就崩溃了</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = appleList;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> plate.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><em>super( in )          ——————  只能存，不能取（其实也能取，取到的都是Object）</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fruitList.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    fruitList.add(<span class="keyword">new</span> <span class="title class_">Banana</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fruitList里面存着Banana，applePlate调用get方法，编译器也不知道返回你什么，是返回Apple类还是Banana类</span></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Apple&gt; applePlate = fruitList;</span><br><span class="line">    applePlate.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    applePlate.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>());</span><br><span class="line">    applePlate.add(<span class="keyword">new</span> <span class="title class_">GreenApple</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>别搞蒙了 super不是指能存入Apple的父类，是指能存入Apple的子类。这和重写父类方法的super不一样。</strong></p>
<h2 id="2-Java-语言中，数组是协变的-泛型不是协变的"><a href="#2-Java-语言中，数组是协变的-泛型不是协变的" class="headerlink" title="2. Java 语言中，数组是协变的,泛型不是协变的"></a>2. Java 语言中，数组是协变的,泛型不是协变的</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    Integer[] c=<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">    Number[] d=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码是支持的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的代码是不允许的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; c=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    ArrayList&lt;Number&gt; d=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-各个场景"><a href="#3-各个场景" class="headerlink" title="3.各个场景"></a>3.各个场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//类场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T ：Activity&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不允许的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T <span class="built_in">super</span> Activity&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不允许的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不允许的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;? <span class="built_in">super</span> Activity&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Source</span>&lt;out T&gt; &#123;</span><br><span class="line">    <span class="keyword">abstract</span> fun <span class="title function_">func</span><span class="params">()</span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Comparable</span>&lt;in T&gt; &#123;</span><br><span class="line">    <span class="keyword">abstract</span> fun <span class="title function_">func</span><span class="params">(t: T)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//变量场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">val list:ArrayList&lt;out String&gt; = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line">ArrayList&lt;? <span class="built_in">super</span> String&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">val list:ArrayList&lt;in String&gt; = ArrayList&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//允许的代码</span></span><br><span class="line">ArrayList&lt;?&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">val list:ArrayList&lt;*&gt; = ArrayList&lt;String&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//不允许的代码</span></span><br><span class="line">ArrayList list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt;();</span><br><span class="line">ArrayList list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;out String&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【?】<strong>【? extends XXX】  和   【? super XXX】只能用在变量引用的泛型上</strong></p>
<h2 id="4-无界类型通配符-Kotlin-使用星号投影"><a href="#4-无界类型通配符-Kotlin-使用星号投影" class="headerlink" title="4.无界类型通配符?, Kotlin 使用星号投影*"></a>4.无界类型通配符<code>?</code>, Kotlin 使用星号投影<code>*</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java    ? 相当于? extend Object   只能get不能set</span></span><br><span class="line">ArrayList&lt;?&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Object a=list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//kotlin     * 相当于 out Any?   只能get不能set</span></span><br><span class="line">val list:ArrayList&lt;*&gt; = ArrayList&lt;String&gt;()</span><br><span class="line">val any= list.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>崩溃知识点</title>
    <url>/post/30488343.html</url>
    <content><![CDATA[<p>一个java层捕捉崩溃的写法</p>
<span id="more"></span>



<h2 id="手动进行消息的loop，并捕捉异常"><a href="#手动进行消息的loop，并捕捉异常" class="headerlink" title="手动进行消息的loop，并捕捉异常"></a>手动进行消息的loop，并捕捉异常</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static void startCatchLooper() &#123;</span><br><span class="line">    new Handler(Looper.getMainLooper()).post(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            loopInner();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static void loopInner() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            Message message = getMessage();</span><br><span class="line">            <span class="comment">//如果忽略该异常，则直接return，否则继续抛出Throwable</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">catch</span>(message,e))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="获得当前执行的Message"><a href="#获得当前执行的Message" class="headerlink" title="获得当前执行的Message"></a>获得当前执行的Message</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static Message getMessage() &#123;</span><br><span class="line">    MessageQueue messageQueue;</span><br><span class="line">    Looper mainLooper = Looper.getMainLooper();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            messageQueue = mainLooper.getQueue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Field fieldQueue = Looper.<span class="keyword">class</span>.getDeclaredField(<span class="string">&quot;mQueue&quot;</span>);</span><br><span class="line">            fieldQueue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            messageQueue = (MessageQueue) fieldQueue.<span class="keyword">get</span>(mainLooper);</span><br><span class="line">        &#125;</span><br><span class="line">        Field fieldMessages = MessageQueue.<span class="keyword">class</span>.getDeclaredField(<span class="string">&quot;mMessages&quot;</span>);</span><br><span class="line">        fieldMessages.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Message) fieldMessages.<span class="keyword">get</span>(messageQueue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>崩溃</tag>
      </tags>
  </entry>
  <entry>
    <title>网络加载点9图的补充</title>
    <url>/post/eb603a17.html</url>
    <content><![CDATA[<p> 参考文档：</p>
<p><a href="https://juejin.cn/post/7147458316103811108">对嘛！这才是从网络加载点9图的正确姿势</a></p>
<p>去看上面的文档了解，这个博客文只是些个人记录</p>
<p>目前方案是调用 AAPT 预处理完后再上传后台</p>
<span id="more"></span>



<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-制作点9图"><a href="#1-制作点9图" class="headerlink" title="1.制作点9图"></a>1.制作点9图</h3><p>傻瓜式教程</p>
<p><a href="https://blog.csdn.net/sunbinkang/article/details/77331718">Android studio中.9图片的含义及制作教程</a></p>
<h3 id="2-AAPT命令"><a href="#2-AAPT命令" class="headerlink" title="2.AAPT命令"></a>2.AAPT命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\AppData\Local\Android\Sdk\build-tools\31.0.0\aapt.exe c -v -S  . -C .\9out</span><br></pre></td></tr></table></figure>

<p>将该命令打包成cmd文件，与要处理的点9图处于同一个目录，运行即可（将aapt目录改为自己的对应目录）</p>
<p>上面命令调用AAPT处理资源，将有黑边的点9图转换为正常PNG</p>
<h3 id="2-获得点9图对应的Bitmap"><a href="#2-获得点9图对应的Bitmap" class="headerlink" title="2.获得点9图对应的Bitmap"></a>2.获得点9图对应的Bitmap</h3><p>参考文档方案测试不行，因此我的处理是不让Glide生成Bitmap，只是下载文件，然后BitmapFactory转为Bitmap</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Glide.with(view)</span><br><span class="line">.asFile()</span><br><span class="line">.load(url)</span><br><span class="line">.into(<span class="keyword">object</span> :</span><br><span class="line">      SimpleTarget&lt;File&gt;() &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResourceReady</span><span class="params">(resource: <span class="type">File</span>, p1: <span class="type">Transition</span>&lt;<span class="type">in</span> <span class="type">File</span>&gt;?)</span></span> &#123;</span><br><span class="line">              <span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(resource.absolutePath)</span><br><span class="line">              <span class="keyword">val</span> chunk = bitmap.ninePatchChunk</span><br><span class="line">              <span class="keyword">val</span> drawable = <span class="keyword">if</span> (NinePatch.isNinePatchChunk(chunk)) &#123;</span><br><span class="line">                  NinePatchDrawable(context.resources, bitmap, chunk, Rect(), <span class="literal">null</span>)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  BitmapDrawable(context.resources, bitmap)</span><br><span class="line">              &#125;</span><br><span class="line">              bgView.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>



<p><font color='red'>感觉好像都搞定了。。。。。  但还剩下个Bitmap的密度问题</font></p>
<h3 id="3-获得正确密度尺寸的Bitmap"><a href="#3-获得正确密度尺寸的Bitmap" class="headerlink" title="3.获得正确密度尺寸的Bitmap"></a>3.获得正确密度尺寸的Bitmap</h3><p>BitmapFactory.decodeFile(String pathName)  方法的调用不会根据手机尺寸进行图片的缩放</p>
<p><a href="https://blog.csdn.net/sevensundark/article/details/7616450">屏幕密度掺入BitmapFactory里decodeFile与decodeResource的差异</a></p>
<p>这样子会导致一个问题</p>
<p>假如我们有个气泡右上角有个50x50 px的皇冠小icon，我们想要的效果.9图的效果肯定是 </p>
<ol>
<li>在一倍密度的手机下皇冠大小是50x50 px，剩下的气泡部分由可拉伸的区域填补</li>
<li>在二倍密度的手机下皇冠大小是100x100 px，剩下的气泡部分由可拉伸的区域填补</li>
<li>在三倍密度的手机下皇冠大小是150x150 px，剩下的气泡部分由可拉伸的区域填补</li>
</ol>
<p>直接调用BitmapFactory.decodeFile(String pathName)  会导致在任何尺寸的手机上气泡皇冠的大小都是50 X 50 px。所以我们要根据手机的尺寸进行图片的缩放</p>
<p>修改第二步代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Glide.with(view)</span><br><span class="line">.asFile()</span><br><span class="line">.load(url)</span><br><span class="line">.into(<span class="keyword">object</span> :</span><br><span class="line">      SimpleTarget&lt;File&gt;() &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResourceReady</span><span class="params">(resource: <span class="type">File</span>, p1: <span class="type">Transition</span>&lt;<span class="type">in</span> <span class="type">File</span>&gt;?)</span></span> &#123;</span><br><span class="line">              opt.inDensity = <span class="number">320</span> <span class="comment">//这是因为我的原始图片是个二倍图 160*2</span></span><br><span class="line">              opt.inTargetDensity = BasicConfig.appContext.resources.displayMetrics.densityDpi</span><br><span class="line">              <span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(resource.absolutePath, opt)</span><br><span class="line">              <span class="keyword">val</span> chunk = bitmap.ninePatchChunk</span><br><span class="line">              <span class="keyword">val</span> drawable = <span class="keyword">if</span> (NinePatch.isNinePatchChunk(chunk)) &#123;</span><br><span class="line">                  NinePatchDrawable(context.resources, bitmap, chunk, Rect(), <span class="literal">null</span>)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  BitmapDrawable(context.resources, bitmap)</span><br><span class="line">              &#125;</span><br><span class="line">              bgView.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>



<p>  opt.inDensity &#x3D; 160*你的图片是几倍图  。我的情况是设计提供的是二倍图，所以设置为320</p>
<p>Keep Moving Forward</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>点9图</tag>
      </tags>
  </entry>
</search>
